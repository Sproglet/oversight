+ clean_tmp
+ rm -f '/tmp/catalog.[0-9]*__*' '/tmp/awk.[0-9]*.0_DUMMY'
+ set +e
+ echo '[INFO] catalog version 20090605-1BETA'
[INFO] catalog version 20090605-1BETA
+ sed 's/^/\[INFO\] os version /' /proc/version
[INFO] os version CYGWIN_NT-5.1 1.5.25(0.156/4/2) 2008-06-12 19:34
+ '[' -f /mnt/syb8634/VERSION ']'
+ catalog DEBUG .
+ DUMMY_ONE_LINE_FILE=/proc/5988/cmdline
++ get_unpak_cfg
++ for ext in cfg cfg.example
++ for nzd in '"$APPDIR"' /share/Apps/NZBGet/.nzbget /share/.nzbget
++ '[' -f /home/alord/devel/oversight/unpak.cfg ']'
++ echo /home/alord/devel/oversight/unpak.cfg
++ return
+ UNPAK_CFG=/home/alord/devel/oversight/unpak.cfg
+ Q=''\'''
+ LS=ls
+ '[' -f /share/bin/ls ']'
+ LS=/share/bin/ls
++ date +%Y%m%d%H%M%S
+ awk '
#ALL# #catalog.awk
#ALL# 
#ALL# #Pad episode but dont assume its a number .eg 03a for Big Brother
#ALL# function padEpisode(e) {
#ALL#     if (match(e,"^[0-9][0-9]")) {
#ALL#         return e;
#ALL#     } else {
#ALL#         return "0"e;
#ALL#     }
#ALL# }
#ALL# 
#ALL# function DEBUG(x) {
#ALL#         
#ALL#     if ( DBG ) {
#ALL#         print "[DEBUG]  " (systime()-ELAPSED_TIME)" : " x;
#ALL#     }
#ALL# 
#ALL# }
#ALL# 
#ALL# # Load configuration file
#ALL# function loadSettings(file_name,\
#ALL# i,n,v) {
#ALL# 
#ALL#     INFO("load "file_name);
#ALL#     FS="\n";
#ALL#     while((getline option < file_name ) > 0 ) {
#ALL# 
#ALL#         #remove comment - hash without a preceeding blackslash
#ALL#         if ((i=match(option,"[^\\\\]#")) > 0) {
#ALL#             option = substr(option,1,i);
#ALL#         }
#ALL# 
#ALL#         #remove spaces around =
#ALL#         sub(/ *= */,"=",option);
#ALL#         option=trim(option);
#ALL#         # remove outer quotes
#ALL#         sub("=[\""gQuote"]","=",option);
#ALL#         sub("[\""gQuote"]$","",option);
#ALL#         if (match(option,"^[A-Za-z0-9_]+=")) {
#ALL#             n=substr(option,1,RLENGTH-1);
#ALL#             v=substr(option,RLENGTH+1);
#ALL#             gsub(/ *[,|] */,"|",v);
#ALL# 
#ALL#             if (n in gSettings) {
#ALL#                 WARNING("Duplicate setting "n"=["v"]");
#ALL#             }
#ALL#             gSettings[n] = v;
#ALL#             gSettingsOrig[n]=v;
#ALL#             INFO(n"=["v"]");
#ALL#         }
#ALL#     }
#ALL#     close(file_name);
#ALL# }
#ALL# 
#ALL# # Note we dont call the real init code until after the command line variables are read.
#ALL# BEGIN {
#ALL#     g_opt_dry_run=0;
#ALL#     yes="yes";
#ALL#     no="no";
#ALL#     gQuote="'\''";
#ALL# 
#ALL#     gImdbIdRegex="\\<tt[0-9]+\\>";
#ALL# 
#ALL#     gTime=ELAPSED_TIME=systime();
#ALL#     if (gunzip != "") {
#ALL#         INFO("using gunzip="gunzip);
#ALL#     }
#ALL#     get_folders_from_args(FOLDER_ARR);
#ALL# }
#ALL# 
#ALL# END{
#ALL#     apikey="A110A5718F912DAF";
#ALL# 
#ALL#     load_catalog_settings(APPDIR"/catalog.cfg");
#ALL# 
#ALL#     INDEX_DB_NEW = INDEX_DB "." PID ".new";
#ALL#     INDEX_DB_OLD = INDEX_DB ".old";
#ALL# 
#ALL#     INDEX_DB_OVW = INDEX_DB ".idx";
#ALL#     INDEX_DB_OVW_NEW = INDEX_DB_OVW "." PID ".new";
#ALL# 
#ALL# 
#ALL#     DEBUG("RENAME_TV="RENAME_TV);
#ALL#     DEBUG("RENAME_FILM="RENAME_FILM);
#ALL# 
#ALL#     setDbFields();
#ALL# 
#ALL#     #Values for action field
#ALL#     ACTION_NONE="0";
#ALL#     ACTION_REMOVE="r";
#ALL#     ACTION_DELETE_MEDIA="d";
#ALL#     ACTION_DELETE_ALL="D";
#ALL# 
#ALL#     poster_prefix = gSettings["catalog_poster_prefix"];
#ALL#     if (gSettings["catalog_poster_location"] == "internal" ) {
#ALL#         poster_prefix = "ovs:" POSTER "/" poster_prefix;
#ALL#     }
#ALL# 
#ALL#     gSettings["catalog_format_tags"]="\\<("tolower(gSettings["catalog_format_tags"])")\\>";
#ALL# 
#ALL#     gsub(/ /,"%20",gSettings["catalog_cert_country_list"]);
#ALL#     split(gSettings["catalog_cert_country_list"],gCertificateCountries,"|");
#ALL# 
#ALL#     gExtList1="avi|mkv|mp4|ts|m2ts|xmv|mpg|mpeg|wmv";
#ALL#     gExtList2="img|iso";
#ALL# 
#ALL#     gExtList1=tolower(gExtList1) "|" toupper(gExtList1);
#ALL#     gExtList2=tolower(gExtList2) "|" toupper(gExtList2);
#ALL# 
#ALL#     gExtRegexIso="\\.("gExtList2")$";
#ALL#     INFO(gExtRegexIso);
#ALL# 
#ALL#     gExtRegEx1="\\.("gExtList1")$";
#ALL#     INFO(gExtRegEx1);
#ALL# 
#ALL#     gExtRegExAll="\\.("gExtList1"|"gExtList2")$";
#ALL#     INFO(gExtRegExAll);
#ALL# 
#ALL#     split(gSettings["catalog_title_country_list"],gTitleCountries,"|");
#ALL# 
#ALL#     monthHash("Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec",gMonthToNum);
#ALL#     monthHash("January,February,March,April,May,June,July,August,September,October,November,December",gMonthToNum);
#ALL# 
#ALL#     #For caps function
#ALL#     ABC_STR="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
#ALL#     abc_str=tolower(ABC_STR);
#ALL#     split(ABC_STR,ABC,"");
#ALL#     split(abc_str,abc,"");
#ALL#     
#ALL#     if ( gSettings["catalog_tv_file_fmt"] == "" ) RENAME_TV=0;
#ALL#     if  ( gSettings["catalog_film_folder_fmt"] == "") RENAME_FILM=0;
#ALL# 
#ALL#     CAPTURE_PREFIX="/tmp/catalog."
#ALL# 
#ALL#     ov_count=0;
#ALL# 
#ALL#     THIS_YEAR=substr(NOW,1,4);
#ALL# 
#ALL#     if (RESCAN == 1) {
#ALL#         INFO("Scanning default paths");
#ALL#         split(gSettings["catalog_scan_paths"],FOLDER_ARR,"[,|]");
#ALL#     }
#ALL# 
#ALL#     for(f in FOLDER_ARR) {
#ALL#        DEBUG("Folder:\t"FOLDER_ARR[f]);
#ALL#     }
#ALL#     gMovieFileCount = 0;
#ALL#     gMaxDatabaseId = 0;
#ALL#     DB_SIZE = loadDatabase(DB_ARR,file_to_db);
#ALL#     
#ALL#     if (!g_opt_no_actions) {
#ALL#         loadSettings("/home/alord/devel/oversight/unpak.cfg");
#ALL#         unpak_nmt_pin_root=unpak_option["unpak_nmt_pin_root"];
#ALL#     }
#ALL# 
#ALL#     if (1 in FOLDER_ARR) {
#ALL# 
#ALL#         scan_folder_for_new_media(FOLDER_ARR);
#ALL# 
#ALL#         process_scanned_files();
#ALL#     }
#ALL# 
#ALL# 
#ALL#     if (g_opt_dry_run) {
#ALL# 
#ALL#         INFO( "End dry_run");
#ALL# 
#ALL#     } else {
#ALL# 
#ALL#         remove_absent_files_from_new_db(DB_SIZE,DB_ARR,INDEX_DB_NEW); 
#ALL# 
#ALL#         remove_files_with_delete_actions(DB_ARR,DB_SIZE);
#ALL# 
#ALL#         add_new_scanned_files_to_database(INDEX_DB_NEW,DB_SIZE,DB_ARR,file_to_db);
#ALL# 
#ALL#         ov_count = build_overview_array(INDEX_DB_NEW,overview_db);
#ALL# 
#ALL#         add_overview_indices(overview_db,ov_count);
#ALL# 
#ALL#         write_overview(overview_db,ov_count,INDEX_DB_OVW_NEW);
#ALL# 
#ALL#         replace_database_with_new();
#ALL#     }
#ALL# 
#ALL#     clean_capture_files();
#ALL# 
#ALL#     et=systime()-ELAPSED_TIME;
#ALL# 
#ALL#     for(dm in g_search_count) {
#ALL#         DEBUG(dm" : "g_search_count[dm]" searches"); 
#ALL#     }
#ALL#     DEBUG("Direct search hits/misses = "g_direct_search_hit"/"g_direct_search_miss);
#ALL#     DEBUG("Deep search hits/misses = "g_deep_search_hit"/"g_deep_search_miss);
#ALL#     DEBUG(sprintf("Finished: Elapsed time %dm %ds",int(et/60),(et%60)));
#ALL# 
#ALL#     #Check script
#ALL#     for(i in gSettings) {
#ALL#         if (!(i in gSettingsOrig)) {
#ALL#             WARNING("Undefined setting "i" referenced");
#ALL#         }
#ALL#     }
#ALL# }
#ALL# 
#ALL# function monthHash(nameList,hash,\
#ALL# names) {
#ALL#     split(nameList,names,",");
#ALL#     for(i in names) {
#ALL#         hash[tolower(names[i])] = i+0;
#ALL#     }
#ALL# } 
#ALL# 
#ALL# function replace_database_with_new() {
#ALL# 
#ALL#     INFO("Replace Database");
#ALL# 
#ALL#     system("cp -f \""INDEX_DB"\" \""INDEX_DB_OLD"\"");
#ALL# 
#ALL#     touchAndMove(INDEX_DB_NEW,INDEX_DB);
#ALL#     touchAndMove(INDEX_DB_OVW_NEW,INDEX_DB_OVW);
#ALL# 
#ALL#     setPermissions(quoteFile(INDEX_DB)"*");
#ALL# }
#ALL# 
#ALL# function setPermissions(shellArg) {
#ALL#     if (ENVIRON["USER"] != alord ) {
#ALL#         system("chown alord:None "shellArg);
#ALL#     }
#ALL# }
#ALL# 
#ALL# function caps(text,\
#ALL# i,j) {
#ALL#     #First letter
#ALL#     if ((j=index(abc_str,substr(text,1,1))) > 0) {
#ALL#         text = ABC[j] substr(text,2);
#ALL#     }
#ALL#     #Other letters.
#ALL#     for(i in ABC) {
#ALL#         while ((j=index(text," " abc[i] )) > 0) {
#ALL#             text=substr(text,1,j) ABC[i] substr(text,j+2);
#ALL#         }
#ALL#     }
#ALL#     return text;
#ALL# }
#ALL# 
#ALL# function setDbFields() {
#ALL#     #DB fields should start with underscore to speed grepping etc.
#ALL#     ID=dbField("_id","ID","",0);
#ALL# 
#ALL#     #List of all related detail items. ie tv shows in same season
#ALL#     OVERVIEW_DETAILIDLIST=dbField("_did" ,"Ids","",0);
#ALL#     OVERVIEW_EXT_LIST = dbField("_ext","Extensions","",0);
#ALL# 
#ALL#     WATCHED=dbField("_w","Watched","watched",0) ;
#ALL#     ACTION=dbField("_a","Next Operation","",0); # ACTION Tell catalog.sh to do something with this entry (ie delete)
#ALL#     PARTS=dbField("_pt","PARTS","","");
#ALL#     FILE=dbField("_F","FILE","filenameandpath","");
#ALL#     NAME=dbField("_N","NAME","","");
#ALL#     DIR=dbField("_D","DIR","","");
#ALL# 
#ALL# 
#ALL#     ORIG_TITLE=dbField("_ot","ORIG_TITLE","originaltitle","");
#ALL#     TITLE=dbField("_T","Title","title",".titleseason") ;
#ALL#     AKA=dbField("_K","AKA","","");
#ALL# 
#ALL#     CATEGORY=dbField("_C","Category","",0);
#ALL#     ADDITIONAL_INFO=dbField("_ai","Additional Info","","");
#ALL#     YEAR=dbField("_Y","Year","year",0) ;
#ALL# 
#ALL#     SEASON=dbField("_s","Season","season",0) ;
#ALL#     EPISODE=dbField("_e","Episode","episode","");
#ALL#     SEASON0=dbField("0_s","0SEASON","","");
#ALL#     EPISODE0=dbField("0_e","0EPISODE","","");
#ALL# 
#ALL#     GENRE=dbField("_G","Genre","genre",0) ;
#ALL#     RATING=dbField("_r","Rating","rating","");
#ALL#     CERT=dbField("_R","CERT","mpaa",0); #Not standard?
#ALL#     PLOT=dbField("_P","Plot","plot","");
#ALL#     URL=dbField("_U","URL","url","");
#ALL#     POSTER=dbField("_J","Poster","thumb",0);
#ALL# 
#ALL#     DOWNLOADTIME=dbField("_DT","Downloaded","",0);
#ALL#     INDEXTIME=dbField("_IT","Indexed","",1);
#ALL#     FILETIME=dbField("_FT","Modified","",0);
#ALL# 
#ALL#     SEARCH=dbField("_SRCH","Search URL","search","");
#ALL#     PROD=dbField("_p","ProdId.","","");
#ALL#     AIRDATE=dbField("_ad","Air Date","aired","");
#ALL#     TVCOM=dbField("_tc","TvCom","","");
#ALL#     EPTITLE=dbField("_et","Episode Title","title","");
#ALL#     EPTITLEIMDB=dbField("_eti","Episode Title(imdb)","","");
#ALL#     AIRDATEIMDB=dbField("_adi","Air Date(imdb)","","");
#ALL#     NFO=dbField("_nfo","NFO","nfo","");
#ALL# 
#ALL#     IMDBID=dbField("_imdb","IMDBID","id","");
#ALL# }
#ALL# 
#ALL# 
#ALL# #Setup dbField identifier, pretty name , and overview field.
#ALL# #overview == "" : dont add to overview
#ALL# #overview == 0 : add to overview
#ALL# #overview == 1 : add to overview and create index using field "key"
#ALL# #overview == field2 : add to overview and create index using field "field2"
#ALL# function dbField(key,name,tag,overview) {
#ALL#     gDbFieldName[key]=name;
#ALL#     gDbTag2FieldId[tag]=key;
#ALL#     gDbFieldId2Tag[key]=tag;
#ALL#     if (overview != "" ) {
#ALL#         if (overview == 1 ) {
#ALL#             OVERVIEW_FIELDS[key] = key;
#ALL#             DEBUG("Overview field ["key"] = ["name"] sorted");
#ALL#         } else {
#ALL#             OVERVIEW_FIELDS[key] = overview;
#ALL#             if (overview == 0) {
#ALL#                 DEBUG("Overview field ["key"] = ["name"] unsorted");
#ALL#             } else {
#ALL#                 DEBUG("Overview field ["key"] = ["name"] sorted by ["overview"]");
#ALL#             }
#ALL#         }
#ALL#     }
#ALL#     return key;
#ALL# }
#ALL# 
#ALL# function scan_folder_for_new_media(folderArray,\
#ALL# temp,f) {
#ALL# 
#ALL#     #Need to make sure the ls format is as "standard"
#ALL#     gLS_FILE_POS=0;
#ALL#     gLS_TIME_POS=0; 
#ALL# 
#ALL#     temp=NEW_CAPTURE_FILE("MOVIEFILES")
#ALL# 
#ALL#     findLSFormat(temp);
#ALL# 
#ALL#     for(f in folderArray) {
#ALL#         scan_contents(folderArray[f],temp);
#ALL#     }
#ALL# }
#ALL# 
#ALL# function findLSFormat(temp,\
#ALL# folderNameNext,i) {
#ALL#     DEBUG("Finding LS Format");
#ALL#     exec(LS" -Rl /proc/"PID" > "temp );
#ALL#     FS=" ";
#ALL#     folderNameNext=1;
#ALL#     
#ALL#     while((getline < temp) > 0 ) {
#ALL#         if (folderNameNext) {
#ALL#            currentFolder = $0;
#ALL#            sub(/\/*:/,"",currentFolder);
#ALL#            DEBUG("Folder = "currentFolder);
#ALL#            folderNameNext=0;
#ALL#         } else if ($0 == "" ) {
#ALL#             folderNameNext=1;
#ALL#         }  else {
#ALL#             if (substr(currentFolder,1,5) == "/proc" ) {
#ALL#                if (index($0,"fd") && match($0,"\\<fd\\>")) {
#ALL#                     INFO("LS Format "$0);
#ALL#                     for(i=1 ; i <= NF ; i++ ) {
#ALL#                         if ($i == "fd") gLS_FILE_POS=i;
#ALL#                         if (index($i,":")) gLS_TIME_POS=i;
#ALL#                     }
#ALL#                     DEBUG("File Position at "gLS_FILE_POS);
#ALL#                     DEBUG("Time Position at "gLS_TIME_POS);
#ALL#                     break;
#ALL#                 } 
#ALL#             }
#ALL#         }
#ALL#     }
#ALL#     close(temp);
#ALL# }
#ALL# 
#ALL# # Input is ls -lR or ls -l
#ALL# function scan_contents(root,temp,
#ALL# currentFolder,skipFolder,i,j,folderNameNext,perms,w5,lsMonth,lsDate,lsTimeOrYear,f,d,extRe) {
#ALL# 
#ALL#     DEBUG("PreScanning "root);
#ALL#     if (root == "") return;
#ALL# 
#ALL#     #Remove trailing slash. This ensures all folder paths end without trailing slash
#ALL#     if (root != "/" ) {
#ALL#         gsub(/\/+$/,"",root); 
#ALL#     }
#ALL# 
#ALL#     quotedRoot=quoteFile(root);
#ALL# 
#ALL#     extRe="\\.[^.]+$";
#ALL# 
#ALL#     #We use ls -R instead of find to get a sorted list.
#ALL#     #There may be some issue with this.
#ALL# 
#ALL#     #First file /proc/$$ is to check ls format
#ALL#     DEBUG("Scanning "quotedRoot);
#ALL#     # We want to list a file which may be a file, folder or symlink.
#ALL#     # ls -Rl x/ will do symlink but not normal file.
#ALL#     #so do  ls -Rl x/ || ls -Rl x  
#ALL#     exec("( "LS" -Rl "quotedRoot"/ || "LS" -Rl "quotedRoot" ) > "temp );
#ALL#     FS=" ";
#ALL#     currentFolder = root;
#ALL#     skipFolder=0;
#ALL#     folderNameNext=1;
#ALL#     while((getline < temp) > 0 ) {
#ALL# 
#ALL# 
#ALL#         DEBUG( "ls: ["$0"]"); 
#ALL# 
#ALL#         store=0;
#ALL#         perms=$1;
#ALL# 
#ALL#         if ($0 == "") continue;
#ALL# 
#ALL#         if (match($0,"^total [0-9]+$")) continue;
#ALL# 
#ALL#         if (!match(substr(perms,2,9),"^[-rwxsSt]+$") ) {
#ALL#             #Just entered a folder
#ALL#            currentFolder = $0;
#ALL#            sub(/\/*:/,"",currentFolder);
#ALL#            DEBUG("Folder = "currentFolder);
#ALL#            folderNameNext=0;
#ALL#             if ( currentFolder ~ gSettings["catalog_ignore_paths"] ) {
#ALL#                 skipFolder=1;
#ALL#                 INFO("Ignore path "currentFolder);
#ALL#             } else if(unpak_nmt_pin_root != "" && index(currentFolder,unpak_nmt_pin_root) == 1) {
#ALL#                 skipFolder=1;
#ALL#                 INFO("SKIPPING "currentFolder);
#ALL#             } else if (currentFolder in gFolderCount) {
#ALL# 
#ALL#                 WARNING("Already visited "currentFolder);
#ALL#                 skipFolder=1;
#ALL# 
#ALL# 
#ALL#             } else {
#ALL#                 skipFolder=0;
#ALL#                 gFolderMediaCount[currentFolder]=0;
#ALL#                 gFolderInfoCount[currentFolder]=0;
#ALL#                 gFolderCount[currentFolder]=0;
#ALL#                 DEBUG("Clear folder count ["currentFolder"]");
#ALL#             }
#ALL# 
#ALL#         } else if (!skipFolder) {
#ALL# 
#ALL#             lc=tolower($0);
#ALL# 
#ALL#             if ( lc ~ gSettings["catalog_ignore_names"] ) {
#ALL#                 INFO("Ignore name "$0);
#ALL#                 continue;
#ALL#             }
#ALL# 
#ALL#             w5=lsMonth=lsDate=lsTimeOrYear="";
#ALL# 
#ALL#             # ls -l format. Extract file time...
#ALL#             w5=$5;
#ALL# 
#ALL#             if ( gLS_TIME_POS ) {
#ALL#                 lsMonth=$(gLS_TIME_POS-2);
#ALL#                 lsDate=$(gLS_TIME_POS-1);
#ALL#                 lsTimeOrYear=$(gLS_TIME_POS);
#ALL#             }
#ALL# 
#ALL#             #Get Position of word at gLS_FILE_POS.
#ALL#             #(not cannot change $n variables as they cause corruption of $0.eg 
#ALL#             #double spaces collapsed.
#ALL#             pos=index($0,$2);
#ALL#             for(i=3 ; i <= gLS_FILE_POS ; i++ ) {
#ALL#                 pos=indexFrom($0,$i,pos+length($(i-1)));
#ALL#             }
#ALL#             $0=substr($0,pos);
#ALL#             lc=tolower($0);
#ALL# 
#ALL#             #Check for VIDEO_TS
#ALL#             if (substr(perms,1,1) != "-") {
#ALL#                 if (substr(perms,1,1) == "d") {
#ALL#                     #Directory
#ALL#                     if (currentFolder in gFolderCount) {
#ALL#                         gFolderCount[currentFolder]++;
#ALL#                     }
#ALL# 
#ALL#                     DEBUG("Folder ["$0"]");
#ALL# 
#ALL#                     if ($0 == "VIDEO_TS") {
#ALL# 
#ALL#                         if (match(currentFolder,"/[^/]+$")) {
#ALL#                             f = substr(currentFolder,RSTART+1);
#ALL#                             d = substr(currentFolder,1,RSTART-1);
#ALL#                         }
#ALL# 
#ALL#                         storeMovie(gMovieFileCount,f"/",d,calcTimestamp(lsMonth,lsDate,lsTimeOrYear,NOW));
#ALL#                         setNfo(gMovieFileCount,"/$",".nfo");
#ALL#                         gMovieFileCount++;
#ALL#                         skipFolder=1;
#ALL#                     }
#ALL#                 }
#ALL#                 continue;
#ALL#             }
#ALL#             
#ALL# 
#ALL#             if (match(lc,gExtRegexIso)) {
#ALL#                 #ISO images.
#ALL# 
#ALL#                 if (length(w5) < 10) {
#ALL#                     INFO("Skipping image - too small");
#ALL#                 } else {
#ALL#                     store=1;
#ALL#                 }
#ALL# 
#ALL#             } else if (match($0,"unpak.???$")) {
#ALL#                 
#ALL#                 gDate[currentFolder"/"$0] = calcTimestamp(lsMonth,lsDate,lsTimeOrYear,NOW);
#ALL# 
#ALL#             } else if (match(lc,gExtRegEx1)) {
#ALL# 
#ALL#                 DEBUG("gFolderMediaCount[currentFolder]="gFolderMediaCount[currentFolder]);
#ALL#                 #Only add it if previous one is not part of same file.
#ALL#                 if (gFolderMediaCount[currentFolder] > 0 && gMovieFileCount >= 1 ) {
#ALL#                   if ( checkMultiPart($0,gMovieFileCount) ) {
#ALL#                       #replace xxx.cd1.ext with xxx.nfo (Internet convention)
#ALL#                       #otherwise leave xxx.cd1.yyy.ext with xxx.cd1.yyy.nfo (YAMJ convention)
#ALL#                       setNfo(gMovieFileCount-1,".(|cd|disk|disc|part)[1-9]" extRe,".nfo");
#ALL#                   } else {
#ALL#                       store=2;
#ALL#                   }
#ALL#                } else {
#ALL#                    #This is the first/only avi for this film/show
#ALL#                    store=2;
#ALL#                }
#ALL# 
#ALL#             } else if (match(lc,"\\.nfo$")) {
#ALL# 
#ALL#                 nfo=currentFolder"/"$0;
#ALL#                 gNfoExists[nfo]=1;
#ALL#                 gFolderInfoCount[currentFolder]++;
#ALL#                 gFolderInfoName[currentFolder]=nfo;
#ALL#                 gDate[nfo] = calcTimestamp(lsMonth,lsDate,lsTimeOrYear,NOW);
#ALL#             }
#ALL# 
#ALL#             if (store) {
#ALL# 
#ALL#                 storeMovie(gMovieFileCount,$0,currentFolder,calcTimestamp(lsMonth,lsDate,lsTimeOrYear,NOW));
#ALL#                 setNfo(gMovieFileCount,"\\.[^.]+$",".nfo");
#ALL#                 gMovieFileCount++;
#ALL#             }
#ALL#         }
#ALL#     }
#ALL#     close(temp);
#ALL#     DEBUG("Found "gMovieFileCount" items to add");
#ALL# }
#ALL# 
#ALL# # Convert a glob pattern to a regular exp.
#ALL# # *=anything,?=single char, <=start of word , >=end of word |=OR
#ALL# function glob2re(glob) {
#ALL#     gsub(/[.]/,"\\.",glob);
#ALL#     gsub(/[*]/,".*",glob);
#ALL#     gsub(/[?]/,".",glob);
#ALL#     gsub(/[<]/,"\\<",glob);
#ALL#     gsub(/ *, */,"|",glob);
#ALL#     gsub(/[>]/,"\\>",glob);
#ALL#     return "^("glob")$";
#ALL# }
#ALL# 
#ALL# function csv2re(text) {
#ALL#     gsub(/ *, */,"|",text);
#ALL#     return "("text")";
#ALL# }
#ALL# 
#ALL# function storeMovie(idx,file,folder,timeStamp) {
#ALL# 
#ALL#     gFolderMediaCount[folder]++;
#ALL# 
#ALL#     gFolder[idx]=folder;
#ALL#     gMovieFiles[idx] = file;
#ALL#     DEBUG("Storing ["gFolder[idx]"]["gMovieFiles[idx]"]");
#ALL# 
#ALL#     #used when pruning the old index.
#ALL#     gMovieFilePresent[folder"/"file] = 1;
#ALL#     gFileTime[idx] = timeStamp;
#ALL# }
#ALL# 
#ALL# #Check if a filename is similar to the previous stored filename.
#ALL# # lcName         : lower case file name
#ALL# # count          : next index in array
#ALL# # multiPartRegex : regex that matches the part tag of the file
#ALL# function checkMultiPart(name,count,\
#ALL# i,firstName) {
#ALL#     firstName=gMovieFiles[count-1];
#ALL# 
#ALL#     DEBUG("Multipart check ["firstName"] vs ["name"]");
#ALL#     if (length(firstName) != length(name)) {
#ALL#         DEBUG("length ["firstName"] != ["name"]");
#ALL#         return 0;
#ALL#     }
#ALL#     if (firstName == name) return 0;
#ALL# 
#ALL#     for(i=1 ; i <= length(firstName) ; i++ ) {
#ALL#         if (substr(firstName,i,1) != substr(name,i,1)) {
#ALL#             break;
#ALL#         }
#ALL#     }
#ALL#     DEBUG("difference at "i);
#ALL# 
#ALL#     if (substr(firstName,i+1) != substr(name,i+1)) {
#ALL#         DEBUG("no match last bit ["substr(firstName,i+1)"] != ["substr(name,i+1)"]");
#ALL#         return 0;
#ALL#     }
#ALL# 
#ALL#     if (substr(firstName,i-1,2) ~ "[^0-9]1" || substr(firstName,i-2,3) ~ "[^EeXx0-9][0-9]1" ) {
#ALL#         # Avoid matching tv programs e0n x0n 11n
#ALL#         # At this stage we have not done full filename analysis to determine if it matches a tv program
#ALL#         # That is done during the scrape stage by "checkTvFilenameFormat". This is just a quick way.
#ALL#         # It makes sure the character 2 digits before is not E,X or 0-9. It will fail the name is cd001 
#ALL#         if (!(substr(name,i,1) ~ "[2-9]")) {
#ALL#             DEBUG("no match on [2-9]"substr(name,i,1));
#ALL#             return 0;
#ALL#         }
#ALL#         #continue 
#ALL#     } else if (substr(firstName,i,1) ~ "[Aa]") {
#ALL#         if (!(substr(name,i,1) ~ "[A-Fa-f]")) {
#ALL#             DEBUG("no match on [A-Fa-f]"substr(name,i,1));
#ALL#             return 0;
#ALL#         }
#ALL#         #continue 
#ALL#     } else {
#ALL#         DEBUG("no match on [^0-9][Aa1]");
#ALL#         return 0;
#ALL#     }
#ALL# 
#ALL#     INFO("Found multi part file - linked with "firstName);
#ALL#     gParts[count-1] = (gParts[count-1] =="" ? "" : gParts[count-1]"/" ) name;
#ALL#     gMultiPartTagPos[count-1] = i;
#ALL#     return 1;
#ALL# }
#ALL# 
#ALL# # set the nfo file by replacing the pattern with the given text.
#ALL# function setNfo(idx,pattern,replace,\
#ALL# nfo,lcNfo) {
#ALL#     #Add a lookup to nfo file
#ALL#     nfo=gMovieFiles[idx];
#ALL#     lcNfo = tolower(nfo);
#ALL#     if (match(lcNfo,pattern)) {
#ALL#         nfo=substr(nfo,1,RSTART-1) replace substr(nfo,RSTART+RLENGTH);
#ALL#         gNfoDefault[idx] = getPath(nfo,gFolder[idx]);
#ALL#         DEBUG("Storing default nfo path ["gNfoDefault[idx]"]");
#ALL#     }
#ALL# }
#ALL# 
#ALL# function exec(cmd, err) {
#ALL#    DEBUG("SYSTEM : "substr(cmd,1,100)"...");
#ALL#    if ((err=system(cmd)) != 0) {
#ALL#       ERROR("Return code "err" executing "cmd) ;
#ALL#   }
#ALL#   return err;
#ALL# }
#ALL# 
#ALL# #The new index is read again to create the overview index
#ALL# function build_overview_array(databaseIndex,overview_db,\
#ALL# i,ext,seriesId,fields,ep1,ov_count,firstTvSeriesEntry) {
#ALL# 
#ALL#     DEBUG("build_overview_array");
#ALL#     FS="\t";
#ALL#     ov_count=0;
#ALL#     while((getline < databaseIndex ) > 0 ) {
#ALL# 
#ALL#         if (substr($0,1,1) == "\t") {
#ALL# 
#ALL#             delete fields;
#ALL#             for(i=2 ; i < NF ; i+= 2 ) {
#ALL#                 fields[$i] = $(i+1);
#ALL#             }
#ALL# 
#ALL#             #If there is some kind of pending action, but actions are disabled, then we dont
#ALL#             #want to add this record to the overview 
#ALL#             if (fields[ACTION] != ACTION_NONE && g_opt_no_actions==1) {
#ALL#                 INFO("noactions:Excluding item "fields[ID]" from overview list");
#ALL#                 continue;
#ALL#             }
#ALL# 
#ALL#             seriesId=tolower(fields[TITLE]"\t"fields[SEASON]);
#ALL# 
#ALL#             ext=fields[FILE];
#ALL#             if (isDvdDir(ext)) {
#ALL#                 ext = "/"; #VIDEO_TS
#ALL#             } else {
#ALL#                 ext=tolower(ext);
#ALL#                 sub(/.*\./,"",ext);
#ALL#             }
#ALL# 
#ALL#             if (fields[CATEGORY] != "T" || !( seriesId in firstTvSeriesEntry )) {
#ALL# 
#ALL#                 #Just add this item if its not a tv show or the first occurence of tv show.
#ALL#                 fields[OVERVIEW_EXT_LIST]=ext;
#ALL#                 fields[OVERVIEW_DETAILIDLIST]=fields[ID];
#ALL# 
#ALL#                 #DEBUG("Overview idlist ["seriesId"] = "fields[OVERVIEW_DETAILIDLIST]"]");
#ALL#                 if (fields[CATEGORY] == "T") {
#ALL#                     firstTvSeriesEntry[seriesId] = ov_count;
#ALL#                 }
#ALL# 
#ALL#                 sub(/^[Tt]he /,"",seriesId);
#ALL#                 overview_db[".titleseason",ov_count] = seriesId;
#ALL# 
#ALL#                 for(i in OVERVIEW_FIELDS) {
#ALL#                     if(i in fields) {
#ALL#                         overview_db[i,ov_count] = fields[i];
#ALL#                     }
#ALL#                 }
#ALL#                 #Add the full file for uncategorised items
#ALL#                 if (fields[CATEGORY] == "") {
#ALL#                     overview_db[FILE,ov_count] = fields[FILE];
#ALL#                 }
#ALL#                 ov_count++;
#ALL# 
#ALL#             } else {
#ALL# 
#ALL#                 #Seen this tv show already, update the existing tv entry (id,ext and timestamps)
#ALL#                 ep1 = firstTvSeriesEntry[seriesId];
#ALL# 
#ALL#                 overview_db[OVERVIEW_DETAILIDLIST,ep1] =overview_db[OVERVIEW_DETAILIDLIST,ep1]  "|" fields[ID];
#ALL# 
#ALL#                 if (index(overview_db[OVERVIEW_EXT_LIST,ep1],ext) == 0) {
#ALL#                     overview_db[OVERVIEW_EXT_LIST,ep1]=overview_db[OVERVIEW_EXT_LIST,ep1] "|" ext;
#ALL#                 }
#ALL# 
#ALL#                 if (fields[FILETIME] > overview_db[FILETIME,ep1]) {
#ALL#                     overview_db[FILETIME,ep1]=fields[FILETIME];
#ALL#                 }
#ALL#                 if (fields[INDEXTIME] > overview_db[INDEXTIME,ep1]) {
#ALL#                     overview_db[INDEXTIME,ep1]=fields[INDEXTIME];
#ALL#                 }
#ALL#                 if (fields[DOWNLOADTIME] > overview_db[DOWNLOADTIME,ep1]) {
#ALL#                     overview_db[DOWNLOADTIME,ep1]=fields[DOWNLOADTIME];
#ALL#                 }
#ALL# 
#ALL#                 if (fields[WATCHED] == 0) {
#ALL#                     overview_db[WATCHED,ep1]=0;
#ALL#                 }
#ALL#             }
#ALL#         }
#ALL#     }
#ALL#     close(databaseIndex);
#ALL#     return ov_count;
#ALL# }
#ALL# 
#ALL# function add_overview_indices(overview_db,ov_count,\
#ALL#     f) {
#ALL# 
#ALL#     DEBUG("add_overview_indices");
#ALL# 
#ALL#     # Now add the sorted indices..
#ALL# 
#ALL#     for(f in OVERVIEW_FIELDS) {
#ALL#         if (OVERVIEW_FIELDS[f] != 0) {
#ALL#             add_overview_index(overview_db,ov_count,f);
#ALL#         }
#ALL#     }
#ALL# }
#ALL# 
#ALL# # Add a sorted index to the data
#ALL# function add_overview_index(overview_db,ov_count,name,
#ALL#   row,ord) {
#ALL#     for(row = 0 ; row < ov_count ; row++ ) {
#ALL#         ord[row]=row;
#ALL#     }
#ALL# 
#ALL#     sortField=OVERVIEW_FIELDS[name];
#ALL#     if (substr(sortField,1,1) == ".") {
#ALL#         sortField = substr(sortField,2);
#ALL#     }
#ALL#     DEBUG("Creating index for "name" using "sortField" on "ov_count" items");
#ALL#     heapsort(ov_count, OVERVIEW_FIELDS[name],1,ord,overview_db);
#ALL# 
#ALL#     #Note ord[] maps a sort position to a record index
#ALL#     #When storing against a record we need to store the sort position
#ALL#     #so store row(position) in record ord[row](index)
#ALL#     for(row = 0 ; row < ov_count ; row++ ) {
#ALL#         overview_db["#"name"#",ord[row]] = row;
#ALL#     }
#ALL# }
#ALL# 
#ALL# #Write the new array - except for hidden fields.
#ALL# function write_overview(arr,arrSize,outFile,\
#ALL#     line,r,f,dim,sep,fld,idx) {
#ALL# 
#ALL#     INFO("write_overview");
#ALL#     for(f in arr) {
#ALL# #        split(f,dim,SUBSEP);
#ALL# #        if (substr(dim[1],1,1) != ".") {
#ALL# #            line[dim[2]] = line[dim[2]]  dim[1] "\t" arr[f] "\t";
#ALL# #        }
#ALL#         if (substr(f,1,1) == ".") continue;
#ALL#         sep = index(f,SUBSEP);
#ALL#         fld=substr(f,1,sep-1);
#ALL#         idx = substr(f,sep+1);
#ALL#         line[idx] = line[idx] fld "\t" arr[f] "\t" ;       
#ALL#     }
#ALL#     for(r in line) {
#ALL#         print "\t"line[r] > outFile;
#ALL#     }
#ALL#     delete line;
#ALL# }
#ALL# 
#ALL# #A folder is relevant if it is tightly associated with the media it contains.
#ALL# #ie it was created just for that film or tv series.
#ALL# # True is the folder was included as part of the scan and is specific to the current media file
#ALL# function folderIsRelevant(dir) {
#ALL# 
#ALL#     DEBUG("Check parent folder relation to media ["dir"]");
#ALL#         if ( !(dir in gFolderCount) || gFolderCount[dir] == "") { 
#ALL#             DEBUG("unknown folder ["dir"]" );
#ALL#             return 0;
#ALL#         }
#ALL#     #Ensure the folder was scanned and also it has 2 or fewer sub folders (VIDEO_TS,AUDIO_TS)
#ALL#     if (gFolderCount[dir] > 2 ) {
#ALL#         DEBUG("Too many sub folders - general folder");
#ALL#         return 0;
#ALL#     }
#ALL#    if (gFolderMediaCount[dir] > 2 ) {
#ALL#        DEBUG("Too much media  general folder");
#ALL#        return 0;
#ALL#    }
#ALL#    return 1;
#ALL# }
#ALL# # If no direct urls found. Search using file names.
#ALL# function searchInternetForImdbLink(idx,\
#ALL# url,triedTitles,txt,titlesRequired,linksRequired) {
#ALL# 
#ALL#     titlesRequired = 0+gSettings["catalog_imdb_titles_required"];
#ALL#     linksRequired = 0+gSettings["catalog_imdb_links_required"];
#ALL#     
#ALL#     txt = basename(gMovieFiles[idx]);
#ALL#     if (tolower(txt) != "dvd_volume" ) {
#ALL#         url=searchHeuristicsForImdbLink(idx,txt,triedTitles,titlesRequired,linksRequired);
#ALL#     }
#ALL# 
#ALL#     if ( url == "" ) {
#ALL#         txt2 = remove_scene_name_and_parts(idx);
#ALL#         if (txt2 != txt ) {
#ALL#             #Because we have lost some info (the release group is removed) the required threshold is increased.
#ALL#             url=searchHeuristicsForImdbLink(idx,txt2,triedTitles,titlesRequired+1,linksRequired+1);
#ALL#         }
#ALL#     }
#ALL# 
#ALL#     if (url == "" && match(gMovieFiles[idx],gExtRegexIso)) {
#ALL#         txt = getIsoTitle(gFolder[idx]"/"gMovieFiles[idx]);
#ALL#         if (length(txt) > 3 ) {
#ALL#             url=searchHeuristicsForImdbLink(idx,txt,triedTitles,titlesRequired,linksRequired);
#ALL#         }
#ALL#     }
#ALL# 
#ALL#     if (url == "" && folderIsRelevant(gFolder[idx])) {
#ALL#         url=searchHeuristicsForImdbLink(idx,basename(gFolder[idx]),triedTitles,titlesRequired,linksRequired);
#ALL#     }
#ALL# 
#ALL#     return url;
#ALL# }
#ALL# 
#ALL# function remove_scene_name_and_parts(idx,\
#ALL# txt) {
#ALL#     # Remove first word - which is often a scene tag
#ALL#     #This could affect the search adversely, esp if the film name is abbreviated.
#ALL#     # Too much information is lost. eg coa-v-xvid will eventually become just v
#ALL#     #so we do this last. 
#ALL#     txt = tolower(basename(gMovieFiles[idx]));
#ALL# 
#ALL#     #Remove the cd1 partb bit.
#ALL#     if (idx in gMultiPartTagPos) {
#ALL#         txt = substr(txt,1,gMultiPartTagPos[idx]-1);
#ALL#     }
#ALL# 
#ALL#     #remove scene name - hopefully
#ALL#     sub(/^[a-z]{1,4}-/,"",txt);
#ALL# 
#ALL#     return txt;
#ALL# }
#ALL# 
#ALL# function mergeSearchKeywords(text,keywordArray,\
#ALL# heuristicId) {
#ALL#     # Build array of different styles of keyword search. eg [a b] [+a +b] ["a b"]
#ALL#     for(heuristicId =  0 ; heuristicId <= 1 ; heuristicId++ ) {
#ALL#         keywords =fileNameToSearchKeywords(text,heuristicId);
#ALL#         keywordArray[keywords]=1;
#ALL#     }
#ALL# }
#ALL# 
#ALL# 
#ALL# function searchHeuristicsForImdbLink(idx,text,triedTitles,titlesRequired,linksRequired,\
#ALL# heuristicId,bestUrl,k,k2,x,keywords,text_no_underscore) {
#ALL# 
#ALL#     mergeSearchKeywords(text,k);
#ALL# 
#ALL#     text_no_underscore = text;
#ALL#     gsub(/_/," ",text_no_underscore);
#ALL#     gsub("[[][^]]+[]]","",text_no_underscore);
#ALL#     if (text_no_underscore != text) {
#ALL#         mergeSearchKeywords(text_no_underscore,k);
#ALL#     }
#ALL# 
#ALL#     bestUrl = searchArrayForIMDB(k,linksRequired,triedTitles);
#ALL# 
#ALL#     if (bestUrl == "" ) {
#ALL#         bestUrl = deepSearchArrayForIMDB(idx,k,titlesRequired,linksRequired,triedTitles);
#ALL#     }
#ALL# 
#ALL#     return bestUrl;
#ALL# }
#ALL# 
#ALL# # Try all of the array indexs(not values) in web search for imdb link.
#ALL# # Try with and without tv tags
#ALL# function searchArrayForIMDB(k,linkThreshold,triedTitles,\
#ALL# bestUrl,keywords,keywordsSansEpisode) {
#ALL# 
#ALL#     DEBUG("direct search...");
#ALL#     bestUrl = searchArrayForIMDB2(k,linkThreshold,triedTitles);
#ALL# 
#ALL#     if (bestUrl == "") {
#ALL#         # Remove episode tags and try again
#ALL#         for(keywords in k) {
#ALL#             if (sub(/ *s[0-9][0-9]e[0-9][0-9].*/,"",keywords)) {
#ALL#                 keywordsSansEpisode[keywords]=1;
#ALL#             }
#ALL#         }
#ALL#         bestUrl = searchArrayForIMDB2(keywordsSansEpisode,linkThreshold,triedTitles);
#ALL#     }
#ALL# 
#ALL#     DEBUG("direct search : nothing found");
#ALL#     g_direct_search_miss++;
#ALL#     return bestUrl;
#ALL# }
#ALL# 
#ALL# function searchArrayForIMDB2(k,linkThreshold,triedTitles,\
#ALL# bestUrl,keywords) {
#ALL#     # Try simple keyword searches with imdb keywords added.
#ALL#     for(keywords in k) {
#ALL#         DEBUG("direct search ["keywords"]...");
#ALL#         if (keywords in triedTitles) {
#ALL#             INFO("Already tried ["keywords"]");
#ALL#         } else {
#ALL#             INFO("direct search ["keywords"]");
#ALL#             bestUrl = searchForIMDB(keywords,linkThreshold);
#ALL#             if (bestUrl != "") {
#ALL#                 INFO("direct search : Found ["bestUrl"]with direct search ["keywords"]");
#ALL#                 g_direct_search_hit++;
#ALL#                 return bestUrl;
#ALL#             }
#ALL#         }
#ALL#     }
#ALL#     return "";
#ALL# }
#ALL# 
#ALL# # Try all of the array indexs(not values) in deep web search for imdb link.
#ALL# # Deep search = just search without imdb to get titles from results then find common substring and 
#ALL# # use this substring for imdb search.
#ALL# function deepSearchArrayForIMDB(idx,k,titleThreshold,linkThreshold,triedTitles,\
#ALL# bestUrl,keywords,text) {
#ALL#     #Try deep searches.
#ALL#     for(keywords in k) {
#ALL#         #text=searchForBestTitleSubstring(keywords "+nfo+download" ,titleThreshold);
#ALL#         text=searchForBestTitleSubstring(keywords ,titleThreshold);
#ALL#         bestUrl = deepSearchStep2(idx,keywords,text,linkThreshold,triedTitles);
#ALL#         if (bestUrl == "" ) {
#ALL#             # search without episode tag
#ALL#             if (sub(/ *s[0-9][0-9]e[0-9][0-9].*/,"",text)) {
#ALL#                 bestUrl = deepSearchStep2(idx,keywords,text,linkThreshold,triedTitles);
#ALL#             }
#ALL#         }  
#ALL#         if (bestUrl != "" ) {
#ALL#             return bestUrl;
#ALL#         }
#ALL#    }
#ALL#    return "";
#ALL# }
#ALL# function deepSearchStep2(idx,keywords,text,linkThreshold,triedTitles,\
#ALL# bestUrl) {
#ALL#     if (text != "" ) {
#ALL# 
#ALL#         if (text in triedTitles) {
#ALL#             INFO("Already tried ["text"]");
#ALL#         } else {
#ALL#             DEBUG("deep search ["keywords"] => ["text"]");
#ALL#             triedTitles[text]++;
#ALL# 
#ALL#             if (0 && gCategory[idx] == "T") {
#ALL#                 ##bestUrl=getAllInfoFromEpguidesAndImdbLink(idx,text);
#ALL#                 bestUrl=getAllTvInfoAndImdbLink(idx,text);
#ALL#             }
#ALL#             if (bestUrl == "") {
#ALL# 
#ALL#                 #Now search this common title string together with imdb links.
#ALL#                 bestUrl = searchForIMDB(text,linkThreshold);
#ALL#             }
#ALL#             if (bestUrl != "") {
#ALL#                 INFO("Found with deep search ["keywords"]=>["text"]");
#ALL#                 g_deep_search_hit++;
#ALL#                 return bestUrl;
#ALL#             }
#ALL#         }
#ALL#     }
#ALL#     g_deep_search_miss++;
#ALL#     return "";
#ALL# }
#ALL# 
#ALL# # Extract the filename from the path. Note if the file ends in / then the folder is the filename
#ALL# function basename(f) {
#ALL#     if (match(f,"/[^/]+$")) {
#ALL#         f=substr(f,RSTART+1);
#ALL#     } else if (match(f,"/[^/]+/$")) {
#ALL#         f=substr(f,RSTART+1,RLENGTH-2);
#ALL#     }
#ALL#     #DEBUG("Before ext ["f"]");
#ALL#     sub(gExtRegExAll,"",f); #remove extension
#ALL#     #DEBUG("After ext ["f"]");
#ALL#     return tolower(f);
#ALL# }
#ALL# 
#ALL# #Given a list of page titles determine the most frquently occuring substring
#ALL# function get_frequent_substring(titles,threshold,\
#ALL# cleaned_titles,i,j,k,substring_count,substring_words,txt) {
#ALL#     for(i in titles) {
#ALL#         cleaned_titles[i]=tolower(cleanTitle(titles[i]));
#ALL#     }
#ALL# 
#ALL#     dump("cleaned",cleaned_titles);
#ALL# 
#ALL#     #count substrings and add to totals substring_count=count substring_words = number of words
#ALL#     for(i in cleaned_titles) {
#ALL#         #gsub(/\<dr\>/,"doctor",cleaned_titles[i]);
#ALL#         merge_substring_count(cleaned_titles[i],substring_count,substring_words);
#ALL#     }
#ALL# 
#ALL#     #The number of occurences is more important than the number of words.
#ALL#     for(i in substring_count) {
#ALL#         j = substring_count[i]-1 ;
#ALL#         k = substring_words[i]-1 ;
#ALL#         #Increase weighting if it ends in a year.
#ALL#         if ( i ~ "\\<(19|20)[0-9][0-9]$" || i ~ "\\((19|20)[0-9][0-9]\\)$") {
#ALL#             j *= 10 ; 
#ALL#         }
#ALL#         # This is a weighting based on words + number of occurences. Not exact science
#ALL#         # A one word file wont be found (due to -1) but then other rules should find it directly before this.
#ALL#         #substring_count[i] = (j-1) * j * (k-1)*k;
#ALL#         substring_count[i] = j * j * k;
#ALL#         if (substring_count[i] >= threshold+0 ) {
#ALL#             DEBUG("count = "j"\twords="substring_words[i]"\tfinal = "substring_count[i] "\t["i"]");
#ALL#         } else {
#ALL#             delete substring_count[i];
#ALL#         }
#ALL#     }
#ALL#     txt = getMax(substring_count,threshold,1,1);
#ALL#     DEBUG("FOUND["txt"]");
#ALL#     return txt;
#ALL# }
#ALL# 
#ALL# # Count all substrings in text. eg.
#ALL# # "And So say all of us" gives "and" "and so" and so say" ... "so" "so say" etc.
#ALL# function merge_substring_count(title,substring_count,substring_words,\
#ALL# word_count,txt,first_word_pos,e,s,w,start,i,j,sep,current_title_substrings) {
#ALL# 
#ALL#     start = 0 ;
#ALL#     first_word_pos=0;
#ALL# 
#ALL#     DEBUG("Extracting from ["title"]");
#ALL#     #DEBUG("Check against ["catalog_format_tags"]");
#ALL# 
#ALL#     w=1;
#ALL#     sep=",+";
#ALL#     do {
#ALL#         start ++;
#ALL#         e[w-1]=start-2;
#ALL#         s[w++]=start;
#ALL# 
#ALL#         start=indexFrom(title," ",start);
#ALL#     } while (start > 0);
#ALL#     e[w-1]=length(title);
#ALL#     
#ALL#     for(i=1 ; (i in s) ; i++ ) {
#ALL#         for(j=i ; (j in s) ; j++ ) {
#ALL# 
#ALL#             txt=substr(title,s[i],e[j]-s[i]+1);
#ALL# 
#ALL#             #only count strings we havent already seen in this title.
#ALL#             if (!(txt in current_title_substrings)) {
#ALL#                 #DEBUG("Substring = "i"/"s[i]" to "j"/"e[j]" = ["txt"]");
#ALL#                 substring_count[txt] += 1; # (10-s[i]);
#ALL#                 substring_words[txt]=j-i+1;
#ALL#                 current_title_substrings[txt]=1;
#ALL#             }
#ALL#         }
#ALL#     }
#ALL# }
#ALL# 
#ALL# #If stripFormatTags set then only portion before recognised format tags (eg 720p etc) is search.
#ALL# #This helps broaden results and get better consensus from google.
#ALL# function fileNameToSearchKeywords(f,heuristic\
#ALL# ) {
#ALL# 
#ALL#     #heuristic 0 - All words optional (+) and strip format tags strip episode s0ne0n
#ALL#     #heuristic 1 - All words mandatory (+%2B) and strip format tags strip episode s0ne0n
#ALL#     #heuristic 2 - Quoted file search 
#ALL#     f=tolower(f);
#ALL# 
#ALL#     if (heuristic == 0 || heuristic == 1) {
#ALL# 
#ALL#         gsub(/[^-_A-Za-z0-9]+/,"+",f);
#ALL# 
#ALL#         #remove words ending with numbers
#ALL#         #gsub(/\<[A-Za-z]+[0-9]+\>/,"",f);
#ALL# 
#ALL#         #remove everything after a year
#ALL#         if (match(f,"\\<(19|20)[0-9][0-9]\\>")) {
#ALL#             f = substr(f,1,RSTART+RLENGTH);
#ALL#         }
#ALL#         #remove everything after episode
#ALL#         if (match(f,"\\<s[0-9][0-9]e[0-9][0-9]")) {
#ALL#             f = substr(f,1,RSTART+RLENGTH);
#ALL#         }
#ALL# 
#ALL# 
#ALL#         f = remove_format_tags(f);
#ALL# 
#ALL#         #Make words mandatory
#ALL#         if (heuristic == 1) {
#ALL#             DEBUG("Base query = "f);
#ALL#             gsub(/[-+.]/,"+%2B",f);
#ALL#             f="%2B"f;
#ALL#         }
#ALL# 
#ALL#         gsub(/^\+/,"",f);
#ALL#         gsub(/\+$/,"",f);
#ALL# 
#ALL#     } else if (heuristic == 2) {
#ALL# 
#ALL#         f = "%22"f"%22"; #double quotes
#ALL#     }
#ALL#     INFO("Using search method "heuristic" = ["f"]");
#ALL#     return f;
#ALL# }
#ALL# 
#ALL# function remove_format_tags(text,\
#ALL# tag,t) {
#ALL#     gsub(gSettings["catalog_format_tags"]".*","",text);
#ALL#     return text;
#ALL# }
#ALL# 
#ALL# function scrapeIMDBTitlePage(idx,url,\
#ALL# f) {
#ALL# 
#ALL#     if (url ~ "IGNORE" ) return;
#ALL# 
#ALL#     #Remove /combined/episodes from urls given by epguides.
#ALL#     url=extractImdbLink(url);
#ALL#     DEBUG("Setting external url to ["url"]");
#ALL#     gExternalSourceUrl[idx] = url;
#ALL#     
#ALL#     f=getUrl(url,"imdb_main",1);
#ALL# 
#ALL#     if (f != "" ) {
#ALL# 
#ALL#         imdbContentPosition="header";
#ALL# 
#ALL#         DEBUG("START IMDB: title:"gTitle[idx]" poster "gPoster[idx]" genre "gGenre[idx]" cert "gCertRating[idx]" year "gYear[idx]);
#ALL# 
#ALL#         FS="\n";
#ALL#         while(imdbContentPosition != "footer" && (getline < f) > 0  ) {
#ALL#             imdbContentPosition=scrapeIMDBLine(imdbContentPosition,idx,f);
#ALL#         }
#ALL#         close(f);
#ALL#     }
#ALL# }
#ALL# 
#ALL# 
#ALL# ##### LOADING INDEX INTO DB_ARR[] ###############################
#ALL# 
#ALL# #Used by generate nfo
#ALL# function parseDbRow(row,arr,file_count,\
#ALL# fields,f,i,fileRe) {
#ALL#     split(row,fields,"\t");
#ALL#     for(i=2 ; (i in fields) ; i += 2 ) {
#ALL#         arr[fields[i],file_count] = fields[i+1];
#ALL#     }
#ALL#     f=arr[FILE,file_count];
#ALL#     if (index(f,"//")) {
#ALL#         gsub(/\/\/+/,"/",f);
#ALL#         arr[FILE,file_count] = f;
#ALL#     }
#ALL# 
#ALL#     if (isDvdDir(f)) {
#ALL#         fileRe="/[^/]+/$"; # /path/to/name/[VIDEO_TS]
#ALL#     } else {
#ALL#         fileRe="/[^/]+$";  # /path/to/name.avi
#ALL#     }
#ALL# 
#ALL#     if (match(f,fileRe)) {
#ALL#         arr[NAME,file_count] = substr(f,RSTART+1);
#ALL#         arr[DIR,file_count] = substr(f,1,RSTART-1);
#ALL#     }
#ALL# }
#ALL# 
#ALL# function loadDatabase(db,file_to_db,\
#ALL# arr_size,f) {
#ALL# 
#ALL#     arr_size=0;
#ALL#     delete file_to_db;
#ALL# 
#ALL#     INFO("read_database");
#ALL# 
#ALL#     FS="\n";
#ALL#     while((getline < INDEX_DB) > 0 ) {
#ALL#         if ( substr($0,1,1) != "\t" ) { continue; }
#ALL# 
#ALL#         parseDbRow($0,db,arr_size);
#ALL# 
#ALL#         f=db[FILE,arr_size];
#ALL# 
#ALL#         record_action=db[ACTION,arr_size];
#ALL#         if (g_opt_no_actions==0 && record_action != ACTION_NONE) {
#ALL# 
#ALL#             if (record_action == ACTION_REMOVE) {
#ALL# 
#ALL#                 deleteCurrentEntry(db,arr_size);
#ALL# 
#ALL#             } else if (record_action == ACTION_DELETE_MEDIA || record_action == ACTION_DELETE_ALL) {
#ALL# 
#ALL#                 deleteFiles(db,arr_size,db[ACTION,arr_size]);
#ALL#                 deleteCurrentEntry(db,arr_size);
#ALL#             }
#ALL# 
#ALL#         } else if (f in file_to_db ) {
#ALL#             WARNING("Duplicate detected for "f". Ignoring");
#ALL#             deleteCurrentEntry(db,arr_size);
#ALL#         } else {
#ALL#             #DEBUG("Got file ["f"]");
#ALL#             if (g_opt_no_actions && record_action != ACTION_NONE) {
#ALL#                 INFO("noactions:Temporarily including item "db[ID,arr_size]" with action "record_action);
#ALL#             }
#ALL#             file_to_db[f]=arr_size;
#ALL# 
#ALL#             #TODO We could just store the index rather than the original line
#ALL#             index_line[db[FILE,arr_size]] = $0;
#ALL# 
#ALL#             if ( db[FILE,arr_size] == "" ) {
#ALL#                 ERROR("Blank file for ["$0"]");
#ALL#             }
#ALL#             if (db[ID,arr_size] > gMaxDatabaseId) {
#ALL#                 gMaxDatabaseId = db[ID,arr_size];
#ALL#             }
#ALL# 
#ALL#             #DEBUG("Loaded ["f"]");
#ALL#             arr_size++;
#ALL#         }
#ALL#     }
#ALL#     close(INDEX_DB);
#ALL#     return arr_size;
#ALL# }
#ALL# 
#ALL# function deleteCurrentEntry(db,idx, i) {
#ALL# #First field is intentionally blank - lines start with TAB to make field grepping simpler.
#ALL#     for(i=2 ; i < NF ; i+= 2 ) {
#ALL#         delete db[$i,idx];
#ALL#     }
#ALL# }
#ALL# 
#ALL# function getPath(name,localPath) {
#ALL#     if (substr(name,1,1) == "/" ) {
#ALL#         #absolute
#ALL#         return name;
#ALL#     } else if (substr(name,1,4) == "ovs:" ) {
#ALL#         #Paths with ovs:  are relative to oversight folder and are shared between items.(global)
#ALL#         return APPDIR"/db/global/"substr(name,5);
#ALL#     } else {
#ALL#         #Other paths are relative to video folder.
#ALL#         return localPath"/"name;
#ALL#     }
#ALL# }
#ALL# 
#ALL# #Add files to the delete queue
#ALL# function queueFileForDeletion(name,field) {
#ALL#     gFileToDelete[name]=field;
#ALL# }
#ALL# 
#ALL# function remove_files_with_delete_actions(db,file_count,\
#ALL#     f,field,i,deleteFile) {
#ALL# 
#ALL#     INFO("remove_files_with_delete_actions");
#ALL# 
#ALL#     for(f in gFileToDelete) {
#ALL#         field=gFileToDelete[f];
#ALL#         if (field != "" && field != DIR ) {
#ALL#             deleteFile=1;
#ALL#             #check file has no other references 
#ALL#             for(i = 0 ; i < file_count ; i++ ) {
#ALL#                 if (getPath(db[field,i],db[DIR,i]) == f) {
#ALL#                     INFO(f" still in use by item "db[ID,i]);
#ALL#                     deleteFile=0;
#ALL#                     break;
#ALL#                 }
#ALL#             }
#ALL#             if (deleteFile) {
#ALL#                 exec(rm(f,"",1));
#ALL#             }
#ALL#         }
#ALL#     }
#ALL# 
#ALL#     INFO("Deleting folders");
#ALL#     for(f in gFileToDelete) {
#ALL#         field=gFileToDelete[f];
#ALL#         if (field == DIR ) {
#ALL#             # We are expecting rmdir to fail if the is other content!!
#ALL#             INFO("Deleting "f" only if empty");
#ALL#             exec(rmdir(f,"",1));
#ALL#         }
#ALL#     }
#ALL# }
#ALL# 
#ALL# # mode=d delete media only, D=delete all related files.
#ALL# function deleteFiles(db,idx,mode,\
#ALL#     parts,i,d,rmList) {
#ALL#     INFO("Deleting "db[FILE,idx]);
#ALL#     split(db[PARTS,idx],parts,"/");
#ALL#     d=db[DIR,idx];
#ALL# 
#ALL#     #If mode d or D then delete media files
#ALL# 
#ALL#     rmList = quoteFile(db[FILE,idx]);
#ALL#     for (i in parts) {
#ALL#         rmList = rmList " " quoteFile(d"/"parts[i]);
#ALL#     }
#ALL# 
#ALL#     if (mode == ACTION_DELETE_ALL) {
#ALL#         #Also delete any other files with the same basename
#ALL#         p=db[FILE,idx];
#ALL#         sub(/.[^.]+$/,"",p);
#ALL#         rmList = rmList " " quoteFile(p) ".???" ;
#ALL#         for(i in parts) {
#ALL#             p=parts[i];
#ALL#             sub(/.[^.]+$/,"",p);
#ALL#             rmList = rmList " " quoteFile(p) ".???" ;
#ALL#         }
#ALL#         rmList = rmList " unpak.txt unpak.log unpak.state.db unpak.continue unpak.delete.sh unpak.resume" ;
#ALL#         rmList = rmList " *[^A-Za-z0-9]sample[^A-Za-z0-9]*.???" ;
#ALL#         rmList = rmList " *[^A-Za-z0-9]samp[^A-Za-z0-9]*.???" ;
#ALL#         rmList = rmList " *[^A-Za-z0-9]SAMPLE[^A-Za-z0-9]*.???" ;
#ALL#         rmList = rmList " *[^A-Za-z0-9]SAMP[^A-Za-z0-9]*.???" ;
#ALL#     }
#ALL#     exec(" cd "quoteFile(d)" && rm -f -- "rmList " &");
#ALL# 
#ALL#     if (db[NFO,idx] != "") {
#ALL#         queueFileForDeletion(getPath(db[NFO,idx],db[DIR,idx]),NFO);
#ALL#     }
#ALL#     if (db[POSTER,idx] != "") {
#ALL#         queueFileForDeletion(getPath(db[POSTER,idx],db[DIR,idx]),POSTER);
#ALL#     }
#ALL#     queueFileForDeletion(db[DIR,idx],DIR);
#ALL# }
#ALL# 
#ALL# ##### PRUNING DELETED ENTRIES FROM INDEX ###############################
#ALL# 
#ALL# #Check all the links
#ALL# #To quickly find out if a set of files exist use ls
#ALL# function remove_absent_files_from_new_db(dbSize,db,newDbFile,   i,\
#ALL#     list,f,q,maxCommandLength) {
#ALL#     list="";
#ALL#     maxCommandLength=3999;
#ALL# 
#ALL#     DEBUG("remove_absent_files_from_new_db size="dbSize);
#ALL# 
#ALL#     if (g_opt_no_actions) {
#ALL#         #Just copy the file if no actions requested. In this case
#ALL#         #all we want to do are minimal updates so the gui can re-read the
#ALL#         #database index quickly. Eg when marking a file.
#ALL#         system("cp "INDEX_DB" "INDEX_DB_NEW);
#ALL#         return;
#ALL#     }
#ALL# 
#ALL# 
#ALL#     print "#Index" > newDbFile;
#ALL# 
#ALL#     kept_file_count=0;
#ALL#     absent_file_count=0;
#ALL#     updated_file_count=0;
#ALL#     f=NEW_CAPTURE_FILE("PROBEMISSING");
#ALL# 
#ALL#     for(i=0 ; i < dbSize ; i++ ) {
#ALL# 
#ALL#         if (db[FILE,i] == "" ) {
#ALL# 
#ALL#             WARNING("Empty file for index " i);
#ALL# 
#ALL#         } else {
#ALL# 
#ALL#             q=quoteFile(db[FILE,i]);
#ALL#             list2=list " "q;
#ALL# 
#ALL#             if (length(list)+length(q) < maxCommandLength ) {
#ALL#                 list=list " "q;
#ALL#             } else {
#ALL#                 determineFileStatus(f,list,newDbFile);
#ALL#                 list=q
#ALL#             }
#ALL#         }
#ALL#     }
#ALL#     if ( list != "" ) {
#ALL#         determineFileStatus(f,list,newDbFile);
#ALL#     }
#ALL#     INFO("UNCHANGED:"kept_file_count);
#ALL#     INFO("NOT FOUND:"absent_file_count);
#ALL#     INFO("UPDATING :"updated_file_count);
#ALL#     INFO("NEW      :"(gMovieFileCount-updated_file_count));
#ALL# }
#ALL# 
#ALL# #Return single quoted file name. Inner quotes are backslash escaped.
#ALL# function quoteFile(f,
#ALL#     j,ch) {
#ALL#     gsub(gQuote,gQuote "\\"gQuote gQuote,f);
#ALL#     return gQuote f gQuote;
#ALL# }
#ALL# 
#ALL# function determineFileStatus(f,list,newDbFile,\
#ALL# cmd,i,line) {
#ALL#     INFO("Checking batch");
#ALL#     cmd="ls -d -- " list " > " f " 2>&1" 
#ALL#    #DEBUG("######### "cmd" #############");
#ALL#     system(cmd);
#ALL#     FS="\n";
#ALL#     while((getline line < f ) > 0 ) {
#ALL# 
#ALL#         if (line == "" ) continue;
#ALL# 
#ALL#         if ((i=index(line,": No such file or directory")) > 0 || (i=index(line,": Not a directory")) > 0) {
#ALL#            line = substr(line,1,i-1);
#ALL#            i = index(line,"/");
#ALL#            line = substr(line,i);
#ALL# 
#ALL#             INFO("de-listing ["line"]");
#ALL#             absent_file_count++;
#ALL# 
#ALL#         } else if (gMovieFilePresent[line] == 0) {
#ALL# 
#ALL#            #DEBUG("KEEPING ["$0"]");
#ALL#            if (line in index_line) {
#ALL#                print index_line[line] > newDbFile;
#ALL#                kept_file_count++;
#ALL#            } else {
#ALL#                 WARNING("["line"] not present in index");
#ALL#            }
#ALL# 
#ALL#         } else {
#ALL# 
#ALL#            INFO("UPDATING ["line"] later.");
#ALL#             updated_file_count++;
#ALL#         }
#ALL#     }
#ALL#     close(f);
#ALL# }
#ALL# 
#ALL# function calcTimestamp(lsMonth,lsDate,lsTimeOrYear,_default,\
#ALL#     val) {
#ALL#     # Calculate file time...
#ALL#     if (lsMonth == "" ) {
#ALL#         return _default;
#ALL#     } else {
#ALL#         m=gMonthToNum[lsMonth];
#ALL#         d=lsDate;
#ALL#         if (index(lsTimeOrYear,":")) {
#ALL#             #MON dd hh:mm
#ALL#             y=THIS_YEAR;
#ALL#             h=substr(lsTimeOrYear,1,2);
#ALL#             min=substr(lsTimeOrYear,4,2);
#ALL#         } else {
#ALL#             #MON dd yyyy
#ALL#             y=lsTimeOrYear;
#ALL#             h=7;
#ALL#             min=0;
#ALL#         }
#ALL#         val = sprintf("%04d%02d%02d%02d%02d00",y,m,d,h,min); 
#ALL#         if (val > NOW ) {
#ALL#             y--;
#ALL#             val = sprintf("%04d%02d%02d%02d%02d00",y,m,d,h,min); 
#ALL#         }
#ALL#         return val; 
#ALL#     }
#ALL# }
#ALL# 
#ALL# function checkTvFilenameFormat(idx,    details,line,dirs,d,dirCount) {
#ALL# 
#ALL#     line = gMovieFiles[idx];
#ALL# 
#ALL#     #First get season and episode information
#ALL# 
#ALL#    #DEBUG("CHECK TV "line);
#ALL# 
#ALL#     if (extractEpisode(line,idx,details)) {
#ALL#        INFO("Found TV info in file name:"line);
#ALL#     } else {
#ALL#        DEBUG("failed level 0 check tv ["line"]");
#ALL# 
#ALL#        split(gFolder[idx],dirs,"/");
#ALL#        dirCount=0;
#ALL#        for(d in dirs) dirCount++;
#ALL# 
#ALL#        if (dirCount == 0 ) return 0;
#ALL# 
#ALL#        line=dirs[dirCount]"/"line;
#ALL# 
#ALL#        if (extractEpisode(line,idx,details)) {
#ALL#            INFO("Found TV Info in dir/file:"line);
#ALL#         } else {
#ALL#            DEBUG("failed level 1 check tv ["line"]");
#ALL#            if (dirCount == 1 ) return 0;
#ALL#            line=dirs[dirCount-1]"/"line;
#ALL#            if (extractEpisode(line,idx,details)) {
#ALL#                INFO("Found TV Info in dir1/dir2/file:"line);
#ALL#            } else {
#ALL#                DEBUG("failed level 2 check tv ["line"]");
#ALL#                return 0;
#ALL#            }
#ALL#        }
#ALL#     }
#ALL#     DEBUG("CONTINUE CHECK TV "line);
#ALL# 
#ALL#     adjustTitle(idx,details[TITLE],"filename");
#ALL# 
#ALL#     gSeason[idx]=details[SEASON];
#ALL#     gEpisode[idx]=details[EPISODE];
#ALL#     gCategory[idx] = "T";
#ALL#     gAdditionalInfo[idx] = details[ADDITIONAL_INFO];
#ALL# 
#ALL#     # Now check the title.
#ALL#     #TODO
#ALL#     return 1;
#ALL# }
#ALL# 
#ALL# function extractEpisodeByPatterns(line,details,idx) {
#ALL# 
#ALL#     #Note if looking at entire path name folders are seperated by /
#ALL# 
#ALL#     line = tolower(line);
#ALL#     if (!extractEpisodeByPattern(line,0,"\\<","[s][0-9][0-9]?","[/ .]?[de][0-9]+[a-e]?",details,idx)) {  #s00e00 (allow d00a for BigBrother)
#ALL#         if (!extractEpisodeByPattern(line,0,"\\<","[0-9][0-9]?","[/ .]?x[0-9][0-9]?",details,idx)) { #00x00
#ALL#             if (!extractEpisodeByPattern(line,0,"\\<","(series|season|saison|s)[^a-z0-9]*[0-9][0-9]?","[/ .]?(e|ep.?|episode)[^a-z0-9]*[0-9][0-9]?",details,idx)) { #00x00 
#ALL# 
#ALL#                 #remove 264 before trying pure numeric detection
#ALL#                 if (index(line,"x264")) {
#ALL#                     gsub(/\<x264\>/,"x-264",line);
#ALL#                 }
#ALL#                 if (!extractEpisodeByPattern(line,1,"[^-0-9]","[03-9]?[0-9]","/?[0-9][0-9]",details,idx)) { # ...name101...
#ALL# 
#ALL#                     return 0;
#ALL#                 }
#ALL#             }
#ALL#         }
#ALL#     }
#ALL# 
#ALL#    #Note 4 digit season/episode matcing [12]\d\d\d will fail because of confusion with years.
#ALL#     return 1;
#ALL# }
#ALL# 
#ALL# function formatDate(line,\
#ALL# date,nonDate) {
#ALL#     line = shortenMonth(line);
#ALL#     if (!extractDate(line,date,nonDate)) {
#ALL#         return line;
#ALL#     }
#ALL#     line=sprintf("%04d-%02d-%02d",date[3],date[2],date[1]);
#ALL#     return line;
#ALL# }
#ALL# 
#ALL# 
#ALL# # Input date text
#ALL# # Output array[1]=y [2]=m [3]=d 
#ALL# #nonDate[1]=bit before date, nonDate[2]=bit after date
#ALL# # or empty array
#ALL# function extractDate(line,date,nonDate,\
#ALL# y4,d1,d2,d1or2,m1,m2,m1or2,d13up,d,m,y,datePart,textMonth) {
#ALL# 
#ALL#     textMonth = 0;
#ALL#     delete date;
#ALL#     delete nonDate;
#ALL#     #Extract the date.
#ALL#     #because awk doesnt capture submatches we have to do this a slightly painful way.
#ALL#     y4="20[01][0-9]";
#ALL#     m2="(0[1-9]|1[012])";
#ALL#     m1=d1="[1-9]";
#ALL#     d2="([012][0-9]|3[01])";
#ALL#     #d13up="(1[3-9]|2[0-9]|3[01])";
#ALL#     s="[-_. /]";
#ALL#     m1or2 = "(" m1 "|" m2 ")";
#ALL#     d1or2 = "(" d1 "|" d2 ")";
#ALL# 
#ALL#     d = m = y = 0;
#ALL#     if  (match(line,y4 s m1or2 s d1or2)) {
#ALL# 
#ALL#         DEBUG("Date Format found yyyy/mm/dd");
#ALL#         y=1 ; m = 2 ; d=3;
#ALL# 
#ALL#     } else if(match(line,m1or2 s d1or2 s y4)) { #us match before plain eu match
#ALL# 
#ALL#         DEBUG("Date Format found mm/dd/yyyy");
#ALL#         m=1 ; d = 2 ; y=3;
#ALL# 
#ALL#     } else if(match(line,d1or2 s m1or2 s y4)) { #eu
#ALL# 
#ALL#         DEBUG("Date Format found dd/mm/yyyy");
#ALL#         d=1 ; m = 2 ; y=3;
#ALL# 
#ALL#     } else if(match(line,d1or2 s "[A-Za-z]+" s y4)) { #eu
#ALL# 
#ALL#         DEBUG("Date Format found dd Month yyyy");
#ALL#         d=1 ; m = 2 ; y=3;
#ALL#         textMonth = 1;
#ALL# 
#ALL#     } else {
#ALL# 
#ALL#         DEBUG("No date format found");
#ALL#         return 0;
#ALL#     }
#ALL#     datePart = substr(line,RSTART,RLENGTH);
#ALL# 
#ALL#     nonDate[1]=substr(line,1,RSTART-1);
#ALL#     nonDate[2]=substr(line,RSTART+RLENGTH);
#ALL# 
#ALL#     split(datePart,date,s);
#ALL#     d = date[d];
#ALL#     m = date[m];
#ALL#     y = date[y];
#ALL# 
#ALL#     date[1]=y;
#ALL#     date[2]=tolower(m);
#ALL#     date[3]=d;
#ALL# 
#ALL#     if ( textMonth == 1 ) {
#ALL#         if (date[2] in gMonthToNum ) {
#ALL#             date[2] = gMonthToNum[date[2]];
#ALL#         } else {
#ALL#             return 0;
#ALL#         }
#ALL# 
#ALL#     }
#ALL#     return 1;
#ALL# }
#ALL# 
#ALL# # If a line looks like show.name.2009-06-16 then look for episode by date. It requires that
#ALL# # show.name results in good unique match at thetvdb.com. otherwise the show.name is left 
#ALL# # unchanged and the episode number is set to mmdd
#ALL# function extractEpisodeByDates(line,details,\
#ALL# tvdbid,episodeInfo,d,m,y,date,nonDate,title) {
#ALL# 
#ALL#     if (!extractDate(line,date,nonDate)) {
#ALL#         return 0;
#ALL#     }
#ALL# 
#ALL#     rest=nonDate[2];
#ALL#     title = cleanTitle(nonDate[1]);
#ALL# 
#ALL#     y = date[1];
#ALL#     m = date[2];
#ALL#     d = date[3];
#ALL# 
#ALL#     INFO("Found Date y="y" m="m" d="d);
#ALL# 
#ALL#     #search for the showname 
#ALL#     tvdbid = search1TvDbId(title);
#ALL#     if (tvdbid != "") {
#ALL#         fetchXML("http://thetvdb.com/api/GetEpisodeByAirDate.php?apikey="apikey"&seriesid="tvdbid"&airdate="y"-"m"-"d,episodeInfo);
#ALL#         details[TITLE]=title;
#ALL#         details[SEASON]=episodeInfo["/Data/Episode/SeasonNumber"];
#ALL#         details[EPISODE]=episodeInfo["/Data/Episode/EpisodeNumber"];
#ALL#         details[ADDITIONAL_INFO]=episodeInfo["/Data/Episode/EpisodeName"];
#ALL#         #TODO We can cache the above url for later use instead of fetching episode explicitly.
#ALL#     } else {
#ALL#         details[TITLE]=title;
#ALL#         details[SEASON]=y;
#ALL#         details[EPISODE]=sprintf("%02d%02d",m,d);
#ALL#         sub(/\....$/,"",rest);
#ALL#         details[ADDITIONAL_INFO]=cleanTitle(rest);
#ALL#     }
#ALL#     return 1;
#ALL# }
#ALL# 
#ALL# function extractEpisode(line,idx,details,        d,dir) {
#ALL# 
#ALL#     if (!extractEpisodeByPatterns(line,details,"")) {
#ALL#         if (!extractEpisodeByDates(line,details)) {
#ALL#             return 0;
#ALL#         }
#ALL#     }
#ALL# 
#ALL#    DEBUG("Extracted title ["details[TITLE] "]");
#ALL#     if (details[TITLE] == "" ) {
#ALL# 
#ALL#         #File starts with season number eg. ^<season><episode>..." so title must be in folder name.
#ALL# 
#ALL#         split(gFolder[idx],dir,"/"); # split folder
#ALL#         for(d in dir ) { ; } # Count
#ALL# 
#ALL#         details[TITLE] = cleanTitle(dir[d]);
#ALL#         DEBUG("Using parent folder for title ["details[TITLE] "]");
#ALL#         sub(/(S[0-9]|Series|Season) *[0-9]+.*/,"",details[TITLE]);
#ALL#         if (details[TITLE] == "" ) {
#ALL#             # Looks like an intermediate Season folder. Get the parent folder.
#ALL#             details[TITLE] = cleanTitle(dir[d-1]);
#ALL#             DEBUG("Using grandparent folder for title ["details[TITLE] "]");
#ALL#         }
#ALL#     }
#ALL# 
#ALL#     return 1;
#ALL# }
#ALL# 
#ALL# #This would be easier using sed submatches.
#ALL# #More complex approach will fail on backtracking
#ALL# function extractEpisodeByPattern(line,prefixReLen,prefixRe,seasonRe,episodeRe,details,idx,  \
#ALL#     start,tmpDetails) {
#ALL#     if (!match(line,prefixRe seasonRe episodeRe "\\>" )) {
#ALL#         return 0;
#ALL#     }
#ALL# 
#ALL#     DEBUG("ExtractEpisode: line["line"] re["prefixRe seasonRe episodeRe "\\>] match["substr(line,RSTART,RLENGTH)"]" );
#ALL# 
#ALL#     RSTART += prefixReLen;
#ALL#     RLENGTH -= prefixReLen;
#ALL# 
#ALL#     tmpDetails[TITLE] = substr(line,1,RSTART-1);
#ALL#     tmpDetails[ADDITIONAL_INFO]=substr(line,RSTART+RLENGTH);
#ALL# 
#ALL#     line=substr(line,RSTART,RLENGTH); # season episode
#ALL# 
#ALL#     if (index(tmpDetails[TITLE],":") && match(tmpDetails[TITLE],": *")) {
#ALL#         tmpDetails[TITLE] = substr(tmpDetails[TITLE],RSTART+RLENGTH);
#ALL#     }
#ALL#    #Remove release group info
#ALL#    if (index(tmpDetails[TITLE],"-") && match(tmpDetails[TITLE],"^[a-z][a-z0-9]+[-]")) {
#ALL#        tmpTitle=substr(tmpDetails[TITLE],RSTART+RLENGTH);
#ALL#        if (tmpTitle != "" ) {
#ALL#            INFO("Removed group was ["tmpDetails[TITLE]"] now ["tmpTitle"]");
#ALL#            tmpDetails[TITLE]=tmpTitle;
#ALL#        }
#ALL#    }
#ALL# 
#ALL#     tmpDetails[TITLE] = cleanTitle(tmpDetails[TITLE]);
#ALL#     
#ALL#     DEBUG("ExtractEpisode: Title= ["tmpDetails[TITLE]"]");
#ALL# 
#ALL#     if (match(tmpDetails[ADDITIONAL_INFO],gExtRegExAll) ) {
#ALL#         tmpDetails[EXT]=tmpDetails[ADDITIONAL_INFO];
#ALL#         gsub(/\.[^.]*$/,"",tmpDetails[ADDITIONAL_INFO]);
#ALL#         tmpDetails[EXT]=substr(tmpDetails[EXT],length(tmpDetails[ADDITIONAL_INFO])+2);
#ALL#     }
#ALL# 
#ALL#     #Match the episode first to handle 3453 and 456
#ALL#     match(line,episodeRe "$" );
#ALL#     tmpDetails[EPISODE] = substr(line,RSTART,RLENGTH); 
#ALL#     tmpDetails[SEASON] = substr(line,1,RSTART-1);
#ALL# 
#ALL#     #gsub(/[^0-9]+/,"",tmpDetails[EPISODE]); #BB
#ALL#     gsub(/^[^0-9]+/,"",tmpDetails[EPISODE]); #BB
#ALL#     sub(/^0+/,"",tmpDetails[EPISODE]);
#ALL# 
#ALL#     gsub(/^[^0-9]+/,"",tmpDetails[SEASON]);
#ALL#     sub(/^0+/,"",tmpDetails[SEASON]);
#ALL# 
#ALL#     #Return results
#ALL#     for(ee in tmpDetails) {
#ALL#         if (idx != "") {
#ALL#             details[ee,idx]=tmpDetails[ee];
#ALL#         } else {
#ALL#             details[ee]=tmpDetails[ee];
#ALL#         }
#ALL#        DEBUG("tv details "gDbFieldName[ee]"."idx" = "tmpDetails[ee]);
#ALL#     }
#ALL#     return 1;
#ALL# }
#ALL# 
#ALL# ############### GET IMDB URL FROM NFO ########################################
#ALL# 
#ALL# function process_scanned_files(\
#ALL# mNo,file,bestUrl,bestUrlViaEpguide,scanNfo,startTime,elapsedTime,thisTime) {
#ALL# 
#ALL# INFO("process_scanned_files");
#ALL# 
#ALL#     startTime = systime();
#ALL# 
#ALL#     for ( mNo = 0 ; (mNo in gMovieFiles ) ; mNo++ ) {
#ALL# 
#ALL#         itemStartTime = systime();
#ALL# 
#ALL#         bestUrl="";
#ALL# 
#ALL#         scanNfo=0;
#ALL# 
#ALL#         file=gMovieFiles[mNo];
#ALL#         if (file == "" ) continue;
#ALL# 
#ALL#         INFO("\n\t==\t==\t==\t==\t==\t==\t==\t==\t==\t==\t==\t==\t==\t==\t==\t==\t==\n");
#ALL#         INFO(mNo":"file);
#ALL# 
#ALL#         DEBUG("nfo check :"file);
#ALL#         if (!isDvdDir(file) && !match(file,gExtRegExAll)) {
#ALL#             WARNING("Skipping unknown file ["file"]");
#ALL#             continue;
#ALL#         }
#ALL# 
#ALL# 
#ALL#         if (gSettings["catalog_nfo_read"] != "no") {
#ALL# 
#ALL#             if (gNfoExists[gNfoDefault[mNo]]) {
#ALL# 
#ALL#                DEBUG("Using default info to find url");
#ALL#                scanNfo = 1;
#ALL# 
#ALL#             } else if (gFolderMediaCount[gFolder[mNo]] == 1 && gFolderInfoCount[gFolder[mNo]] == 1 && gNfoExists[gFolderInfoName[gFolder[mNo]]]) {
#ALL# 
#ALL#                DEBUG("Using single nfo "gFolderInfoName[gFolder[mNo]]" to find url in folder ["gFolder[mNo]"] for item "mNo);
#ALL# 
#ALL#                gNfoDefault[mNo] = gFolderInfoName[gFolder[mNo]];
#ALL#                scanNfo = 1;
#ALL#            }
#ALL#         }
#ALL# 
#ALL#         if (scanNfo){
#ALL#            bestUrl = scanNfoForImdbLink(mNo,gNfoDefault[mNo]);
#ALL#         }
#ALL# 
#ALL#         # This bit needs review.
#ALL#         # Esp if we have an IMDB - use that to determine category first.
#ALL#         #This will help for TV shows that have odd formatting.
#ALL# 
#ALL#         if (checkTvFilenameFormat(mNo)) {
#ALL#             # TV
#ALL#             # There are different ways to get imdburl for tv show.
#ALL#             # via nfo or determine via epguides search
#ALL#             # If imdb url is provided via nfo we should use that to get epguides link
#ALL#             # rather than using epguides link to get imdb link
#ALL#             if (bestUrl != "") {
#ALL# 
#ALL#                 #Get a better title using link from nfo to scrape epguides  with.
#ALL#                 scrapeIMDBTitlePage(mNo,bestUrl);
#ALL#                 #TODO Need a solid route from imdb link to epguides page.
#ALL#                 bestUrlViaEpguide = getAllTvInfoAndImdbLink(mNo);
#ALL# 
#ALL#             } else {
#ALL# 
#ALL#                 #Get imdb url from eguide first.
#ALL#                 bestUrl = getAllTvInfoAndImdbLink(mNo);
#ALL#                 if (bestUrl == "") {
#ALL#                     bestUrl=searchInternetForImdbLink(mNo);
#ALL#                     scrapeIMDBTitlePage(mNo,bestUrl);
#ALL#                     bestUrl2 = getAllTvInfoAndImdbLink(mNo);
#ALL#                 } else {
#ALL#                     scrapeIMDBTitlePage(mNo,bestUrl);
#ALL#                 }
#ALL#         #epguideSeriesPage="http://google.com/search?q=allintitle%3A+"t2"+site%3Aepguides.com&btnI=Search";
#ALL# 
#ALL#             }
#ALL# 
#ALL#         } else {
#ALL# 
#ALL#             # Film
#ALL#             if (bestUrl == "") {
#ALL# 
#ALL#                 bestUrl=searchInternetForImdbLink(mNo);
#ALL#             }
#ALL# 
#ALL#             if (bestUrl != "") {
#ALL# 
#ALL#                 scrapeIMDBTitlePage(mNo,bestUrl);
#ALL# 
#ALL#             }
#ALL#         }
#ALL# 
#ALL#         fixTitles(mNo);
#ALL#         get_best_episode_title(mNo);
#ALL#         relocate_files(mNo);
#ALL# 
#ALL#         thisTime = systime() - itemStartTime;
#ALL#         elapsedTime = systime() - startTime;
#ALL# 
#ALL#         if (g_opt_dry_run) {
#ALL#             print "dryrun: "gFile[mNo]" -> "gTitle[mNo];
#ALL#         }
#ALL#         DEBUG("processed in "thisTime"s | processed "(mNo+1)" items in "(elapsedTime)"s av time per item " (elapsedTime/(mNo+1)) "s");
#ALL#     }
#ALL# }
#ALL# 
#ALL# #returns imdb url
#ALL# function scanNfoForImdbLink(idx,nfoFile,\
#ALL# foundId) {
#ALL# 
#ALL#     foundId="";
#ALL#     INFO("scanNfoForImdbLink ["nfoFile"]");
#ALL# 
#ALL#     FS="\n";
#ALL#     while(foundId=="" && (getline < nfoFile) > 0 ) {
#ALL# 
#ALL#         foundId = extractImdbLink($0);
#ALL# 
#ALL#     }
#ALL#     close(nfoFile);
#ALL#     INFO("scanNfoForImdbLink = ["foundId"]");
#ALL#     return foundId;
#ALL# }
#ALL# 
#ALL# ############### GET IMDB PAGE FROM URL ########################################
#ALL# 
#ALL# function getAllInfoFromTvDbAndImdbLink(idx,title,\
#ALL# tvDbSeriesPage,url,i) {
#ALL# 
#ALL#     if (title == "") {
#ALL#         title=gTitle[idx];
#ALL#     }
#ALL#     DEBUG("Checking existing mapping for ["title"]");
#ALL#     tvDbSeriesPage = tvDbIndex[title];
#ALL# 
#ALL#     if (tvDbSeriesPage == "" ) {
#ALL#         DEBUG("Checking TvDvTitles for ["title"]");
#ALL# 
#ALL#         tvDbSeriesPage = searchTvDbTitles(title);
#ALL#     }
#ALL# 
#ALL#     if (tvDbSeriesPage == "" ) {
#ALL#         searchAbbreviationAgainstTitles(title,alternateTitles);
#ALL# 
#ALL#         for(i = 1 ; tvDbSeriesPage == "" && (i in alternateTitles) ; i++ ) {
#ALL#             DEBUG("Checking possible abbreviation "alternateTitles[i]);
#ALL#             tvDbSeriesPage = searchTvDbTitles(alternateTitles[i]);
#ALL#         }
#ALL#     }
#ALL# 
#ALL#     if (tvDbSeriesPage == "" ) {
#ALL#         WARNING("getAllInfoFromTvDbAndImdbLink could not find series page");
#ALL#         return "";
#ALL#     } else {
#ALL#         DEBUG("getAllInfoFromTvDbAndImdbLink Search looking at "tvDbSeriesPage);
#ALL#         return getTvDbInfo(idx,tvDbSeriesPage);
#ALL#     }
#ALL# }
#ALL# 
#ALL# # Search the epguides menus for names that could be represented by the abbreviation 
#ALL# function searchAbbreviationAgainstTitles(abbrev,alternateTitles,\
#ALL# initial,title2,count) {
#ALL# 
#ALL#     delete alternateTitles;
#ALL# 
#ALL#     count=0;
#ALL# 
#ALL#     if (index(abbrev," ") == 0) {
#ALL#         initial = epguideInitial(abbrev);
#ALL#         DEBUG("Checking "abbrev" for abbreviations on menu page - "initial);
#ALL#         title2 = searchAbbreviation(initial,abbrev);
#ALL#         if (title2 != "" ) {
#ALL#             DEBUG(abbrev" possible abbreviation for "title2);
#ALL#             alternateTitles[++count] = title2;
#ALL#         }
#ALL# 
#ALL#         #if the abbreviation begins with t it may stand for "the" so we need to 
#ALL#         #check the index against the next letter. eg The Ultimate Fighter - tuf on the u page!
#ALL#         if (initial == "t" ) {
#ALL#             initial = epguideInitial(substr(abbrev,2));
#ALL#             if (initial != "t" ) {
#ALL#                 DEBUG("Checking "abbrev" for abbeviations on menu page - "initial);
#ALL#                 title2 = searchAbbreviation(initial,abbrev);
#ALL#                 if (title2 != "" ) {
#ALL#                     DEBUG(abbrev" possible abbreviation for "title2);
#ALL#                     alternateTitles[++count] = title2;
#ALL#                 }
#ALL#             }
#ALL#         }
#ALL#     }
#ALL#     return count;
#ALL# }
#ALL# 
#ALL# function search1TvDbId(title,\
#ALL# allTitles,closeTitles,best) {
#ALL# 
#ALL#     searchTvDb(title,allTitles);
#ALL# 
#ALL#     dump("ALL",allTitles);
#ALL# 
#ALL#     filterSimilarTitles(title,allTitles,closeTitles);
#ALL# 
#ALL#     dump("FILTERED",closeTitles);
#ALL# 
#ALL#     best = selectBestOfBestTitle(closeTitles,idx);
#ALL#     return best;
#ALL# }
#ALL# 
#ALL# # TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
#ALL# # This is the function which will eventually discern between two very closely matched titles.
#ALL# # Eg given conan.obrien.2009.06.24 how do we select between The Late Show with Conan OBrien or the tonight show with Conan OBrien
#ALL# # It is called when there is not enough information in the titles alone to make the call.
#ALL# # it will do things like the following:
#ALL# # IF its a Season 5 DVDRIP then it cant match a show that doesnt have a Season 5 or one
#ALL# # where season 5 is currently airing (watch out for long split season programs like LOST )
#ALL# # Also vice versa if its a TV rip then its probably a show which is currently airing THAT season.
#ALL# # The above rules are also dependent on time of scan so have to be careful.
#ALL# # Another one, for conan obrien use thetvdb get episode by date api call to differentiate between shows.
#ALL# # This is all yucky edge case stuff. And its not coded. In the mean time I will just return the first element :)
#ALL# function selectBestOfBestTitle(titles,idx,\
#ALL# i) {
#ALL#     dump("TODO:Even match",titles);
#ALL#     for(i in titles) {
#ALL#         INFO("Selected:"titles[i]);
#ALL#         return i;
#ALL#     }
#ALL# }
#ALL# 
#ALL# # Search tvDb and return titles hashed by seriesId
#ALL# function searchTvDb(title,allTitles,\
#ALL# f,line,info,bestId,currentId,currentName) {
#ALL# 
#ALL#     delete allTitles;
#ALL# 
#ALL#     bestMatchLevel = 0;
#ALL#     DEBUG("Checking ["title"] against list "menuUrl);
#ALL#     f = getUrl("http://thetvdb.com//api/GetSeries.php?seriesname="title,"tvdb_idx",1);
#ALL#     if (f != "") {
#ALL#         FS="\n";
#ALL#         while((getline line < f) > 0 ) {
#ALL# 
#ALL#             #DEBUG("IN:"line);
#ALL# 
#ALL#             if (index(line,"<Series>") > 0) {
#ALL#                 #This also removes the top level /Data tag in the XML reference
#ALL#                 delete info;
#ALL#             }
#ALL# 
#ALL#             parseXML(line,info);
#ALL# 
#ALL#             if (index(line,"</Series>") > 0) {
#ALL# 
#ALL#                 dump("INFO",info);
#ALL# 
#ALL#                 currentName = info["/Series/SeriesName"];
#ALL# 
#ALL#                 currentId = info["/Series/seriesid"];
#ALL# 
#ALL#                 allTitles[currentId] = currentName;
#ALL#                 delete info;
#ALL# 
#ALL#             }
#ALL#         }
#ALL#         close(f);
#ALL#     }
#ALL# }
#ALL# 
#ALL# function dump(label,array,\
#ALL# i) {
#ALL#     for(i in array) DEBUG(label":"i"=["array[i]"]");
#ALL# }
#ALL# 
#ALL# function searchTvDbTitles(title,\
#ALL# tvdbid,tvDbSeriesUrl) {
#ALL# 
#ALL#     tvdbid = search1TvDbId(title);
#ALL#     if (tvdbid != "") {
#ALL#         tvDbSeriesUrl="http://thetvdb.com/api/"apikey"/series/"tvdbid"/en.xml";
#ALL#     }
#ALL# 
#ALL#     DEBUG("Endpage with url = ["tvDbSeriesUrl"]");
#ALL#     return tvDbSeriesUrl;
#ALL# }
#ALL# 
#ALL# 
#ALL# #Load an xnl file into array - note duplicate elements are clobbered.
#ALL# #To parse xml with duplicate lements call parseXML in a loop and trigger on index(line,"</tag>")
#ALL# function fetchXML(url,urlLabel,xml,\
#ALL# f,line) {
#ALL#     f=getUrl(url,label,1);
#ALL#     if (f != "" ) {
#ALL#         FS="\n";
#ALL#         while((getline line < f) > 0 ) {
#ALL#             parseXML(line,xml);
#ALL#         }
#ALL#         close(f);
#ALL#     }
#ALL# }
#ALL# 
#ALL# #Parse flat XML into an array
#ALL# function parseXML(line,info,\
#ALL# currentTag,start,i,tag,text,lines,parts) {
#ALL# 
#ALL#     # Carriage returns mess up parsing
#ALL#     gsub(/\r/,"",line);
#ALL#     gsub(/\n/,"",line);
#ALL# 
#ALL# 
#ALL#     #break at each tag/endtag
#ALL#     split(line,lines,"<");
#ALL# 
#ALL#     previousTag = info["@LAST"];
#ALL#     currentTag = info["@CURRENT"];
#ALL# 
#ALL#     start=1;
#ALL#     if (substr(line,1,1) != "<") {
#ALL#         #If the line starts with text then add it to the current tag.
#ALL#         info[currentTag] = info[currentTag] lines[1];
#ALL#         start = 2;
#ALL#     }
#ALL# 
#ALL#     for(i = start ; i in lines ; i++ ) {
#ALL# 
#ALL#         previousTag = "";
#ALL#         #split <tag>text  [ or </tag>parenttext ]
#ALL#         split(lines[i],parts,">");
#ALL#         tag = parts[1];
#ALL#         sub(/ .*/,"",tag); #Remove attributes Possible bug if space before element name
#ALL#         text = parts[2];
#ALL# 
#ALL#         if (tag ~ /^\/?[A-Za-z0-9_]+$/ ) {
#ALL# 
#ALL#             if ( substr(tag,1,1) == "/" ) {
#ALL#                 #if end tag, remove it from currentTag
#ALL#                 previousTag = currentTag;
#ALL#                 sub(tag"$","",currentTag);
#ALL# 
#ALL#             } else {
#ALL#                 previousTag = currentTag;
#ALL#                 currentTag = currentTag "/" tag;
#ALL#             }
#ALL#         } else {
#ALL# 
#ALL#             #dont recognise tag - add to text
#ALL#             info[currentTag] = info[currentTag] tag;
#ALL#         }
#ALL# 
#ALL#         info[currentTag] = info[currentTag] text;
#ALL#         if (tag != "" && text != "" ) {
#ALL#             DEBUG("<"currentTag">["info[currentTag]"]");
#ALL#         }
#ALL# 
#ALL#     }
#ALL#     info["@CURRENT"] = currentTag;
#ALL#     info["@LAST"] = previousTag;
#ALL# }
#ALL# 
#ALL# # Return 3 if a possible Title is a very good match for titleIn
#ALL# # Return 2 if it is a likely match
#ALL# # Return 1 if it is an initial or abbreviated type of match.
#ALL# # else return 0
#ALL# function similarTitles(titleIn,possibleTitle,\
#ALL# bPos,cPos,yearOrCountry,matchLevel,shortName,tmp) {
#ALL# 
#ALL#     matchLevel = 0;
#ALL#     yearOrCountry="";
#ALL# 
#ALL#     if ((bPos=index(possibleTitle," (")) > 0) {
#ALL#         yearOrCountry=cleanTitle(substr(possibleTitle,bPos+2));
#ALL#     }
#ALL# 
#ALL#     if ((cPos=index(possibleTitle,",")) > 0) {
#ALL#         shortName=cleanTitle(substr(possibleTitle,1,cPos-1));
#ALL#     }
#ALL# 
#ALL#     possibleTitle=cleanTitle(possibleTitle);
#ALL# 
#ALL#     sub(/^[Tt]he /,"",possibleTitle);
#ALL#     sub(/^[Tt]he /,"",titleIn);
#ALL# 
#ALL#     if (substr(titleIn,2) == substr(possibleTitle,2)) {
#ALL#         DEBUG("Checking ["titleIn"] against ["possibleTitle"]");
#ALL#     }
#ALL#     if (index(possibleTitle,titleIn) == 1) {
#ALL# 
#ALL#         #This will match exact name OR if BOTH contain original year or country
#ALL#         if (possibleTitle == titleIn) {
#ALL#             matchLevel=3;
#ALL# 
#ALL#         } else  if (titleIn == shortName) {
#ALL#             #Check for comma. eg maych House to House,M D
#ALL#             matchLevel=3;
#ALL# 
#ALL#         #This will match if difference is year or country. In this case just pick the 
#ALL#         # last one and user can fix up
#ALL#         } else if ( possibleTitle == titleIn " " yearOrCountry ) {
#ALL#             INFO("match for ["titleIn"+"yearOrCountry"] against ["possibleTitle"]");
#ALL#             matchLevel = 2;
#ALL#         } else {
#ALL#             DEBUG("No match for ["titleIn"+"yearOrCountry"] against ["possibleTitle"]");
#ALL#         }
#ALL#     } else if (index(titleIn,possibleTitle) == 1) {
#ALL#         #Check our title just has a country added
#ALL#         diff=substr(titleIn,length(possibleTitle)+1);
#ALL#         if (substr(diff,1,1) == " ") {
#ALL#             matchLevel = 2;
#ALL#             INFO("match for ["titleIn"] containing ["possibleTitle"]");
#ALL#         }
#ALL#     }
#ALL#     DEBUG("["titleIn"] vs ["possibleTitle"] = "matchLevel);
#ALL#     return matchLevel;
#ALL# }
#ALL# 
#ALL# #Given a title - scan an array or potential titles and return the best matches along with a score
#ALL# #The indexs are carried over to new hash
#ALL# function filterSimilarTitles(title,titleHashIn,titleHashOut,\
#ALL# i,score,bestScore,count) {
#ALL# 
#ALL#     bestScore = -1;
#ALL#     count=0;
#ALL# 
#ALL#     delete titleHashOut;
#ALL# 
#ALL#     for(i in titleHashIn) {
#ALL# 
#ALL#         score = similarTitles(title,titleHashIn[i]);
#ALL#         if (score > bestScore) {
#ALL#             delete titleHashOut;
#ALL#             count=1;
#ALL#             bestScore = score;
#ALL#             titleHashOut[i] = titleHashIn[i];
#ALL#         } else if (score == bestScore) {
#ALL#             titleHashOut[i] = titleHashIn[i];
#ALL#         }
#ALL#     }
#ALL#     DEBUG("Filtered titles with score = "bestScore);
#ALL# 
#ALL#     dump("\t",titleHashOut);
#ALL#     return bestScore;
#ALL# }
#ALL# 
#ALL# # Return the list of names in the epguide menu indexed by link
#ALL# #ALL# function getEpguideNames(letter,names,\
#ALL# #ALL# url,count,title,link,links,i,count2) {
#ALL# #ALL#     url = "http://epguides.com/menu"letter;
#ALL# 
#ALL# #ALL#     count = scanPageForMatches(url,"<li>(|<b>)",links,0);
#ALL# #ALL# 
#ALL# #ALL#     count2 = 0;
#ALL# #ALL#     for(i = 1 ; i <= count ; i++ ) {
#ALL# #ALL# 
#ALL# #ALL#         if (index(links[i],"[radio]") == 0) {
#ALL# #ALL# 
#ALL# #ALL#             title = extractTagText(links[i],"a");
#ALL# #ALL# 
#ALL# #ALL#             if (title != "") {
#ALL# #ALL#                 link = extractAttribute(links[i],"a","href");
#ALL# #ALL#                 sub(/\.\./,"http://epguides.com",link);
#ALL# #ALL#                 gsub(/\&amp;/,"And",title);
#ALL# #ALL#                 names[link] = title;
#ALL# #ALL#                 count2++;
#ALL# #ALL# 
#ALL# #ALL#                 DEBUG("name list "title);
#ALL# #ALL#             }
#ALL# #ALL#         }
#ALL# #ALL#     }
#ALL# #ALL#     DEBUG("Loaded "count2" names");
#ALL# #ALL#     return count2;
#ALL# }
#ALL# 
#ALL# function searchAbbreviation(letter,titleIn,\
#ALL# tmp,possibleTitle,f,names,links,i,ltitle) {
#ALL# 
#ALL# 
#ALL#     ltitle = tolower(titleIn);
#ALL# 
#ALL#     DEBUG("Checking abbreviations ["titleIn"] ");
#ALL# 
#ALL#     getEpguideNames(letter,names);
#ALL# 
#ALL#     for(i in names) {
#ALL# 
#ALL#         possibleTitle = names[i];
#ALL# 
#ALL#         sub(/\(.*/,"",possibleTitle);
#ALL# 
#ALL#         possibleTitle = trim(possibleTitle);
#ALL# 
#ALL#         tmp = threeWordInitials(possibleTitle);
#ALL#         if (tmp != "" && ltitle == tmp) {
#ALL#             break;
#ALL#         }
#ALL# 
#ALL#         # echo Family Guy = fguy only true if 1st word longer?
#ALL#         tmp =initialWord(possibleTitle); 
#ALL#         if (tmp != "" && ltitle == tmp) {
#ALL#             break;
#ALL#         }
#ALL# 
#ALL#         # echo Desperate Housewives = desperateh only true if 1st word shorter?
#ALL#         tmp =wordInitial(possibleTitle); 
#ALL#         if (tmp != "" && ltitle == tmp) {
#ALL#             break;
#ALL#         }
#ALL# 
#ALL#         # Eg greek = grk 
#ALL#         tmp =removeDoubleVowel(possibleTitle); 
#ALL#         if (tmp != "" && ltitle == tmp) {
#ALL#             break;
#ALL#         }
#ALL#         possibleTitle="";
#ALL#     }
#ALL# 
#ALL#     DEBUG("abbreviations = ["possibleTitle"] "tmp);
#ALL#     return possibleTitle;
#ALL# }
#ALL# 
#ALL# #If a title has exactly two words and the first word is longest return initial of word1 followed by word2
#ALL# # eg fguy for family guy
#ALL# function initialWord(text,\
#ALL# spacePos,abbr) {
#ALL#     spacePos = index(text," ");
#ALL#     # Reject no spaces
#ALL#     if (spacePos == 0) {
#ALL#         return "";
#ALL#     }
#ALL#     # Two spaces
#ALL#     if (text ~ / [^ ]+ /) {
#ALL#         return "";
#ALL#     }
#ALL#     if (spacePos*2 < length(text)) {
#ALL#         #first word is short - unlikely to abbreviate this way?
#ALL#         return "";
#ALL#     }
#ALL#     abbr = tolower(substr(text,1,1) substr(text,spacePos+1));
#ALL#     DEBUG(text"|"abbr);
#ALL#     return abbr;
#ALL# }
#ALL# 
#ALL# #If a title has exactly two words and the first word is shortest return word1 followed by initial of word2
#ALL# # eg desperateh for Desperate Housewives
#ALL# function wordInitial(text,\
#ALL# spacePos,abbr) {
#ALL#     text = tolower(text);
#ALL#     spacePos = index(text," ");
#ALL#     # Reject no spaces
#ALL#     if (spacePos == 0) {
#ALL#         return "";
#ALL#     }
#ALL#     #If first word is "the" then unlikely to keep this and abbreviate 2nd word.
#ALL#     if (substr(text,1,4) == "the ") {
#ALL#         return "";
#ALL#     }
#ALL#     # Two spaces
#ALL#     if (text ~ / [^ ]+ /) {
#ALL#         return "";
#ALL#     }
#ALL#     if (spacePos*2 >= length(text)) {
#ALL#         #first word is longer - unlikely to abbreviate this way?
#ALL#         return "";
#ALL#     }
#ALL#     abbr = substr(text,1,spacePos-1) substr(text,spacePos+1,1);
#ALL#     DEBUG(text"|"abbr);
#ALL#     return abbr;
#ALL# }
#ALL# 
#ALL# # If there are 3 or more words then try initials
#ALL# function threeWordInitials(text,\
#ALL# abbr) {
#ALL#     abbr=tolower(text);
#ALL#     if (abbr !~ / [^ ]+ /) {
#ALL#         return "";
#ALL#     }
#ALL#     while(match(abbr,"[a-z][a-z]+")) {
#ALL#         abbr = substr(abbr,1,RSTART-1) " " substr(abbr,RSTART,1) " " substr(abbr,RSTART+RLENGTH+1);
#ALL#     }
#ALL#     gsub(/ +/,"",abbr);
#ALL#     DEBUG(text"|"abbr);
#ALL#     return abbr;
#ALL# }
#ALL# 
#ALL# # if there is one word with a double vowel remove it
#ALL# function removeDoubleVowel(text,\
#ALL# abbr) {
#ALL#     if (index(text," ")) {
#ALL#         return "";
#ALL#     }
#ALL#     sub(/[aeiouAEIOU][aeiouAEIOU]/,"",text);
#ALL#     abbr = tolower(text);
#ALL#     DEBUG(text"|"abbr);
#ALL#     return tolower(abbr);
#ALL# }
#ALL# 
#ALL# 
#ALL# 
#ALL# function getAllTvInfoAndImdbLink(idx,title) {
#ALL#     #return getAllInfoFromEpguidesAndImdbLink(idx,title);
#ALL#     return getAllInfoFromTvDbAndImdbLink(idx,title);
#ALL# }
#ALL# 
#ALL# function getAllInfoFromEpguidesAndImdbLink(idx,title,\
#ALL# epguideSeriesPage,url,alternateTitles,i) {
#ALL# 
#ALL#     if (title == "") {
#ALL#         title=gTitle[idx];
#ALL#     }
#ALL#     epguideSeriesPage = gEpguideIndex[title];
#ALL# 
#ALL#     if (epguideSeriesPage != "" ) {
#ALL#         DEBUG("Using existing mapping for ["title"]="epguideSeriesPage);
#ALL#     } else {
#ALL# 
#ALL#         epguideSeriesPage = searchEpguideTitles(idx,title,1);
#ALL#     }
#ALL# 
#ALL#     if (epguideSeriesPage == "" ) {
#ALL#         searchAbbreviationAgainstTitles(title,alternateTitles);
#ALL# 
#ALL#         for(i = 1 ; epguideSeriesPage == "" && (i in alternateTitles) ; i++ ) {
#ALL#             DEBUG("Checking possible abbreviation "alternateTitles[i]);
#ALL#             epguideSeriesPage = searchEpguideTitles(idx,alternateTitles[i],1);
#ALL#         }
#ALL#     }
#ALL# 
#ALL#     if (epguideSeriesPage == "" ) {
#ALL#         WARNING("getAllInfoFromEpguidesAndImdbLink could not find series page");
#ALL#         return "";
#ALL#     } else {
#ALL#         return getEpguideInfo(idx,epguideSeriesPage);
#ALL#     }
#ALL# }
#ALL# 
#ALL# function epguideInitial(title,\
#ALL# letter) {
#ALL# 
#ALL#     sub(/^[Tt]he /,"",title);
#ALL#     letter=tolower(substr(title,1,1));
#ALL# 
#ALL#     #Thank you epguides for silly numeric-alpha index eg 24 on page t, 90210 page n but 1990 page n too!
#ALL#     if (match(title,"^10") ) {
#ALL#         letter = "t";
#ALL#     } else if (match(title,"^11") ) {
#ALL#         letter = "e";
#ALL#     } else if (match(title,"^1[2-9]") ) {
#ALL#         letter = substr(title,2,1);
#ALL#     }
#ALL# 
#ALL#     if ( letter == "1" ) {
#ALL#         letter = "o";
#ALL#     }else if (match(letter,"^[23]")  ) {
#ALL#         letter = "t";
#ALL#     }else if (match(letter,"^[45]") ) {
#ALL#         letter = "f";
#ALL#     }else if (match(letter,"^[67]") ) {
#ALL#         letter = "s";
#ALL#     }else if ( letter == "8" ) {
#ALL#         letter = "e";
#ALL#     }else if ( letter == "9" ) {
#ALL#         letter = "n";
#ALL#     }
#ALL#     return letter;
#ALL# }
#ALL# 
#ALL# # Returns url to epguides series page
#ALL# function searchEpguideTitles(idx,title,attempt,\
#ALL#     letter,names,namess2,epguideSeriesUrl) {
#ALL# 
#ALL# 
#ALL#     DEBUG("Search of epGuide titles for ["title"]");
#ALL# 
#ALL#     # TV SEARCH
#ALL# 
#ALL#     letter = epguideInitial(title);
#ALL# 
#ALL#     if (match(letter,"[a-z]")) {
#ALL#         #Use epguides menu
#ALL#         DEBUG("Checking ["title"] against list "letter);
#ALL#         getEpguideNames(letter,names);
#ALL# 
#ALL#         filterSimilarTitles(title,names,names2);
#ALL# 
#ALL#         # If more than one title is a good match we need to refine further
#ALL#         # TODO: this needs to be fixed
#ALL#         epguideSeriesUrl = selectBestOfBestTitle(names2,idx);
#ALL# 
#ALL#         DEBUG("Endpage with url = ["epguideSeriesUrl"]");
#ALL#         return epguideSeriesUrl;
#ALL# 
#ALL#     } else {
#ALL#         WARNING("Could not resolve title [" title "] on attempt "attempt);
#ALL#         return "";
#ALL#     }
#ALL# }
#ALL# 
#ALL# function cleanTitle(t) {
#ALL#     if (index(t,"&") && index(t,";")) {
#ALL#         gsub(/[&]amp;/,"and",t);
#ALL#         t = html_decode(t);
#ALL#         gsub(/[&][a-z0-9]+;/,"",t);
#ALL#     }
#ALL#     gsub(/[&]/," and ",t);
#ALL#     gsub(/['\'']/,"",t);
#ALL# 
#ALL#     #Collapse abbreviations. Only if dot is sandwiched between single letters.
#ALL#     #c.s.i.miami => csi.miami
#ALL#     #this has to be done in two stages otherwise the collapsing prevents the next match.
#ALL#     while (match(t,"\\<[A-Za-z]\\>\.\\<[A-Za-z]\\>")) {
#ALL#         t = substr(t,1,RSTART) "@@" substr(t,RSTART+2);
#ALL#     }
#ALL#     gsub(/@@/,"",t);
#ALL# 
#ALL#     gsub(/[^A-Za-z0-9]+/," ",t);
#ALL#     gsub(/ +/," ",t);
#ALL#     t=trim(caps(tolower(t)));
#ALL#     return t;
#ALL# }
#ALL# 
#ALL# function searchForBestTitleSubstring(query,threshold,\
#ALL# titles) {
#ALL#     getTitlesFromGoogle(query,titles);
#ALL#     return get_frequent_substring(titles,threshold);
#ALL# }
#ALL# 
#ALL# function de_emphasise(html) {
#ALL#     gsub(/<(\/|)(b|em|strong|wbr)>/,"",html); #remove emphasis tags
#ALL#     gsub(/<[^\/][^<]+[\/]>/,"",html); #remove single tags eg <wbr />
#ALL#     return html;
#ALL# }
#ALL# 
#ALL# # Search google for a filename and examine titles of search results.
#ALL# #Both google and yahoo have the main title inside <h3><a..>Title</a></h3>
#ALL# function getTitlesFromGoogle(query,titles,\
#ALL# f,h3pos,i,pos,html ) {
#ALL#     i=0;
#ALL#     split("",titles,""); #clear
#ALL# 
#ALL#     f = web_search_to_file(title_search_engines,query,"","search4words",1);
#ALL#     if (f != "") {
#ALL# 
#ALL#         FS="\n";
#ALL#         while((getline html < f) > 0 ) {
#ALL# 
#ALL#             html = de_emphasise(html);
#ALL# 
#ALL# 
#ALL#             #if "Results for:" occurs then ignore everything processed so far. 
#ALL#             #This was output of "Did you mean"
#ALL#             if ((pos=index(html,">Results for:")) > 0 ) {
#ALL#                 delete titles;
#ALL#                 html = substr(html,pos);
#ALL#             }
#ALL# 
#ALL#             #INFO("check h3");
#ALL# 
#ALL#             while((pos=index(html,"<h3")) > 0) {
#ALL#                 html=substr(html,pos);
#ALL#                 h3pos=index(html,"</h3>");
#ALL#                 h3txt=substr(html,1,h3pos);
#ALL#                 html=substr(html,h3pos+4);
#ALL# 
#ALL#                 #INFO("1.h3txt=["h3txt"] pos="pos);
#ALL#                 h3txt = tolower(extractTagText(h3txt,"a"));
#ALL#                 #INFO("2.h3txt=["h3txt"]");
#ALL#                 h3txt = remove_format_tags(h3txt);
#ALL#                 #INFO("h3txt=["h3txt"]");
#ALL#                 if (h3txt != "" ) {
#ALL#                     titles[i++] = h3txt;
#ALL#                 }
#ALL#             }
#ALL#         }
#ALL#         close(f);
#ALL#         rm(f,1);
#ALL#     }
#ALL# }
#ALL# 
#ALL# # This finds the item with the most votes and returns it if it is > threshold.
#ALL# # Special case: If threshold = -1 then the votes must exceed the square of the 
#ALL# # difference between next largest amount.
#ALL# function getMax(arr,requiredThreshold,requireDifferenceSquared,dontRejectCloseSubstrings,\
#ALL# maxValue,maxName,best,nextBest,nextBestName,diff,i,threshold,msg) {
#ALL#     nextBest=0;
#ALL#     maxName="";
#ALL#     best=0;
#ALL#     for(i in arr) {
#ALL#         msg="Score: "arr[i]" for ["i"]";
#ALL#         if (arr[i]+0 >= best+0 ) {
#ALL#             if (maxName == "") {
#ALL#                 INFO(msg": first value ");
#ALL#             } else {
#ALL#                 INFO(msg":"(arr[i]>best?"beats":"matches")" current best of " best " held by ["maxName"]");
#ALL#             }
#ALL#             nextBest = best;
#ALL#             nextBestName = maxName;
#ALL#             best = threshold = arr[i];
#ALL#             maxName = i;
#ALL# 
#ALL#         } else if (arr[i]+0 >= nextBest+0 ) {
#ALL# 
#ALL#             INFO(msg":"(arr[i]>nextBest?"beats":"matches")" current next best of " nextBest " held by ["nextBestName"]");
#ALL#             nextBest = arr[i];
#ALL#             nextBestName = i;
#ALL#             INFO(msg": set as next best");
#ALL# 
#ALL#         } else {
#ALL#             INFO(msg);
#ALL#         }
#ALL#     }
#ALL#     INFO("Best "best"*"arr[i]". Required="requiredThreshold);
#ALL# 
#ALL#     if (0+best < 0+requiredThreshold ) {
#ALL#         INFO("Rejected as "best" does not meet requiredThreshold of "requiredThreshold);
#ALL#         return "";
#ALL#     }
#ALL#     if (requireDifferenceSquared ) {
#ALL#         diff=best-nextBest;
#ALL#         INFO("Next best count = "nextBest" diff^2 = "(diff*diff));
#ALL#         if (diff * diff >= best ) {
#ALL# 
#ALL#             return maxName;
#ALL# 
#ALL#         } else if (dontRejectCloseSubstrings && (index(maxName,nextBestName) || index(nextBestName,maxName))) {
#ALL# 
#ALL#             INFO("Match permitted as next best is a substring");
#ALL#             return maxName;
#ALL# 
#ALL#         } else {
#ALL# 
#ALL#             INFO("But rejected as "best" too close to next best "nextBest" to be certain");
#ALL#             return "";
#ALL# 
#ALL#         }
#ALL#     } else {
#ALL#         return maxName;
#ALL#     }
#ALL# }
#ALL# 
#ALL# #Note the seach is assumed to have the format <h3><a= ...>Result title</a></h3>....
#ALL# #which works for google,yahoo and msn for now.
#ALL# #Searching is more intensive now and it is easy to get google rejecting searches based on traffic.
#ALL# #So we apply round-robin (google,yahoo,msn) to avoid getting blacklisted.
#ALL# # msn search results are similar to google for this purpose.
#ALL# # Both yahoo and msn have uk servers that are different to generic server.
#ALL# # Google is using load balancing (from my UK perspective)
#ALL# #Also the wget function will also sleep based on domain of url
#ALL# function search_url(search_engines,q,num) {
#ALL#     #return "http://www.scroogle.org/cgi-bin/nbbw.cgi?Gw="q;
#ALL#     ++web_search_count;
#ALL#     if (!(web_search_count in search_engines )) web_search_count=1;
#ALL#     if (search_engines[web_search_count] == "google") {
#ALL#         return "http://www.google.com/search?q="q; # (num==""?"":"&num="num);
#ALL#     } else if (search_engines[web_search_count] == "googleie") {
#ALL#         return "http://www.google.ie/search?q="q; # (num==""?"":"&num="num);
#ALL#     } else if (search_engines[web_search_count] == "yahoouk") {
#ALL#         return "http://uk.search.yahoo.com/search?p="q; # (num==""?"":"&n="num);
#ALL#     } else if (search_engines[web_search_count] == "yahoo") {
#ALL#         return "http://search.yahoo.com/search?p="q; # (num==""?"":"&n="num);
#ALL#     } else if (search_engines[web_search_count] == "msn") {
#ALL#         gsub(/inurl%/,"site%",q);
#ALL#         return "http://search.msn.com/results.aspx?q="q;
#ALL#     } else if (search_engines[web_search_count] == "msnuk") {
#ALL#         gsub(/inurl%/,"site%",q);
#ALL#         return "http://search.msn.co.uk/results.aspx?q="q;
#ALL#     } else {
#ALL#         ERROR("Unknown search engine "web_search_count" ["search_engines[web_search_count]"]");
#ALL#         exit;
#ALL#     }
#ALL# }
#ALL# 
#ALL# # Seach a google page for most frequently occuring imdb link
#ALL# function searchForIMDB(keywords,linkThreshold,\
#ALL# url) {
#ALL#     #We want imdb links but not from imdb themselves as this skews the results.
#ALL#     #Also keeping the number of results down helps focus on early matches.
#ALL#     return scanGoogleForBestMatch(link_search_engines,keywords"+%2Bimdb+%2Btitle+-inurl%3Aimdb.com+-inurl%3Aimdb.de",gImdbIdRegex,"search4imdb",linkThreshold,1);
#ALL# }
#ALL# 
#ALL# # This will try each of the search engines in turn. Google has a habit of locking out IP with lots of searches.
#ALL# function web_search_to_file(search_engines,keywords,num,label,cache,\
#ALL# f,x) {
#ALL#     for(x in search_engines) {
#ALL#         f = getUrl(search_url(search_engines,keywords,num),label,cache);
#ALL#         if (f != "") {
#ALL#              return f;
#ALL#         }
#ALL#     }
#ALL#     return "";
#ALL# }
#ALL# 
#ALL# 
#ALL# #Search google page extracting all occurences that match a regex, and return the most
#ALL# #popular match.
#ALL# #url = google url
#ALL# #pattern = regular expression to search for
#ALL# #captureLabel = label for temporary file
#ALL# #threshold = minimum required occurences of matching text.
#ALL# #diffSquaredCheck = set to 1 to ensure the match is significantly more prevalent than other matches, (#best - #nextBest)^2 > best
#ALL# 
#ALL# function scanGoogleForBestMatch(search_engines,keywords,pattern,captureLabel,threshold,diffSquaredCheck,\
#ALL# url,f,iurl,start,nextStart,matchList,bestUrl,x,html) {
#ALL# 
#ALL#     f = web_search_to_file(search_engines,keywords,20,captureLabel,0);
#ALL#     if (f != "") {
#ALL#         FS="\n";
#ALL# 
#ALL#         DEBUG("Looking for "pattern" in "f);
#ALL# 
#ALL#         while((getline html < f) > 0 ) {
#ALL# 
#ALL#             #print("GOOGLE:["html"]");
#ALL#             html = de_emphasise(html);
#ALL# 
#ALL# 
#ALL#             #x=html;gsub(/</,"\n| <",x);DEBUG(x);
#ALL# 
#ALL# 
#ALL# #            split(html,x,"<");
#ALL# #            l=1;
#ALL# #            for(i=1 ; i in x ; i++ ) {
#ALL# #                DEBUG(l" "match(x[i],pattern)" <"x[i]);
#ALL# #                l+=length(x[i])+1;
#ALL# #            }
#ALL# 
#ALL#             start=0;
#ALL# 
#ALL#             # TODO REplace with split loop
#ALL#             while (match(substr(html,start+1),pattern) > 0) {
#ALL#                 
#ALL#                 iurl=substr(html,start+RSTART,RLENGTH);
#ALL#                 nextStart=start+RSTART+RLENGTH;
#ALL# 
#ALL#                 DEBUG("Possible match "iurl);
#ALL# 
#ALL#                 if ( matchList[iurl] == "" ) {
#ALL#                     matchList[iurl]=0;
#ALL#                 }
#ALL#                 matchList[iurl]++;
#ALL# 
#ALL#                 start = nextStart;
#ALL# 
#ALL#             }
#ALL#         }
#ALL#         close(f);
#ALL#     }
#ALL#     # Find the url with the highest count for each index.
#ALL#     #To help stop false matches we requre at least two occurences.
#ALL#     bestUrl=getMax(matchList,threshold,1,0);
#ALL#     if (bestUrl != "") {
#ALL#         return extractImdbLink(bestUrl);
#ALL#     } else  {
#ALL#         return "";
#ALL#     }
#ALL# }
#ALL# 
#ALL# 
#ALL# # Scrape theTvDb series page, populate arrays and return imdb link
#ALL# # http://thetvdb.com/api/key/series/73141/default/1/2/en.xml
#ALL# # http://thetvdb.com/api/key/series/73141/1/en.xml
#ALL# function getTvDbInfo(idx,tvDbSeriesUrl,\
#ALL# f,line,seriesInfo,episodeUrl,episodeInfo,imdbLink,sep,tvdbid) {
#ALL# 
#ALL#     #The url for this link
#ALL#     gEpGuides[idx]=tvDbSeriesUrl;
#ALL# 
#ALL# 
#ALL#     fetchXML(tvDbSeriesUrl,"thetvdb-series",seriesInfo);
#ALL# 
#ALL#     episodeUrl = tvDbSeriesUrl;
#ALL#     sub(/en.xml/,"default/"gSeason[idx]"/"gEpisode[idx]"/en.xml",episodeUrl);
#ALL# 
#ALL#     fetchXML(episodeUrl,"thetvdb-episode",episodeInfo);
#ALL# 
#ALL#     if (gExternalSourceUrl[idx]=="" ) {
#ALL# 
#ALL#         imdbLink = extractImdbLink(seriesInfo["/Data/Series/IMDB_ID"]);
#ALL# 
#ALL#         #Refine the title.
#ALL#         adjustTitle(idx,seriesInfo["/Data/Series/SeriesName"],"thetvdb");
#ALL# 
#ALL#     }
#ALL# 
#ALL#     gYear[idx] = substr(seriesInfo["/Data/Series/FirstAired"],1,4);
#ALL# 
#ALL#     gAirDate[idx]=formatDate(episodeInfo["/Data/Episode/FirstAired"]);
#ALL# 
#ALL#     if (gEpTitle[idx] == "" ) {
#ALL#         sep="";
#ALL#     } else {
#ALL#         sep = "\t";
#ALL#     }
#ALL#     gEpTitle[idx]=gEpTitle[idx] sep episodeInfo["/Data/Episode/EpisodeName"];
#ALL# 
#ALL#     gPlot[idx] = seriesInfo["/Data/Series/Overview"];
#ALL#     gGenre[idx] = seriesInfo["/Data/Series/Genre"];
#ALL#     gCertRating[idx] = seriesInfo["/Data/Series/ContentRating"];
#ALL#     gRating[idx] = seriesInfo["/Data/Series/Rating"];
#ALL# 
#ALL#     if ( gPoster[idx] == "" ) {
#ALL#        poster = seriesInfo["/Data/Series/poster"];
#ALL#        banner = seriesInfo["/Data/Series/banner"];
#ALL#        if (poster != "" ) {
#ALL#            poster = "http://images.thetvdb.com/banners/_cache/" poster;
#ALL#        } else if (banner != "" ) {
#ALL#            poster = "http://images.thetvdb.com/banners/_cache/" banner;
#ALL#        }
#ALL#        getPoster(poster,idx);
#ALL#     }
#ALL#     if (imdbLink == "" ) {
#ALL#         WARNING("getTvDbInfo returns blank imdb url");
#ALL#         return "IGNORE";
#ALL#     } else {
#ALL#         DEBUG("getTvDbInfo returns imdb url ["imdbLink"]");
#ALL#     }
#ALL#     return imdbLink;
#ALL# }
#ALL# 
#ALL# # Scrape epguides series page, populate arrays and return imdb link
#ALL# function getEpguideInfo(idx,epguideSeriesUrl,\
#ALL# f,h1,newTitle,imdbLink,imdbLinkAndText,i,j) {
#ALL# 
#ALL#     #The url for this link
#ALL#     gEpGuides[idx]=epguideSeriesUrl;
#ALL# 
#ALL#     episodeText=sprintf(" %d-%2d ",gSeason[idx],gEpisode[idx]);
#ALL#     episodeTextHyphen=index(episodeText,"-");
#ALL# 
#ALL#     f=getUrl(epguideSeriesUrl,"epguide_nfo",1);
#ALL# 
#ALL#     if (f != "" ) {
#ALL# 
#ALL#         FS="\n";
#ALL#         while((getline < f) > 0 ) {
#ALL# 
#ALL#             #DEBUG("epguide:" $0);
#ALL# 
#ALL#             if (gExternalSourceUrl[idx]=="" ) {
#ALL# 
#ALL#                 if (imdbLinkAndText=="" && index($0,"imdb") && match($0,"<a[^<]+imdb[^<]+</a>")) {
#ALL# 
#ALL#                     imdbLinkAndText=substr($0,RSTART,RLENGTH);
#ALL# 
#ALL#                     imdbLink=extractImdbLink(imdbLinkAndText);
#ALL# 
#ALL#                     #Refine the title.
#ALL#                     newTitle=trim(caps(extractTagText(imdbLinkAndText,"a")));
#ALL#                     adjustTitle(idx,newTitle,"epguides");
#ALL# 
#ALL# 
#ALL#                     #Also get episode info from IMDB. This is to help decide when episode titles in epguides.com are wrong.
#ALL#                     #It may change the link if the original was to the pilot episode rather than the series.
#ALL#                     imdbLink = extractImdbEpisode(idx,imdbLink,0);
#ALL#                 }
#ALL# 
#ALL#             }
#ALL# 
#ALL#             #Sometimes there is more than one entry per episode. So store the links in an array.
#ALL#             #The correct one will be chosen via IMDB episode title.
#ALL#             hyp2=index($0,"-");
#ALL#             if (hyp2 < 20 && hyp2 >= episodeTextHyphen) {
#ALL#                 text2=substr($0,hyp2-episodeTextHyphen+1,length(episodeText));
#ALL#                 #DEBUG("episodeText["episodeText"] text2["text2"] all=["$0"]");
#ALL# 
#ALL#                 if (episodeText == text2) {
#ALL# 
#ALL#                     gProdCode[idx]=trim(substr($0,14,9));
#ALL# 
#ALL#                     gYear[idx]=1900+substr($0,35,2);
#ALL#                     if (gYear[idx] < 1920 ) { gYear[idx] += 100; } 
#ALL# 
#ALL#                     gAirDate[idx]=formatDate(substr($0,28,9));
#ALL# 
#ALL#                     if (gEpTitle[idx] == "" ) {
#ALL#                         sep="";
#ALL#                     } else {
#ALL#                         sep = "\t";
#ALL#                     }
#ALL#                     gTvCom[idx]=gTvCom[idx] sep extractAttribute($0,"a","href");
#ALL# 
#ALL#                     gEpTitle[idx]=gEpTitle[idx] sep extractTagText($0,"a");
#ALL# 
#ALL#                     DEBUG("Found Episode title ["gEpTitle[idx]"]");
#ALL#                 }
#ALL#             }
#ALL# 
#ALL#             #We may have ariived by Google Feeling Lucky so get the real url name
#ALL# 
#ALL#             ## TODO review
#ALL# 
#ALL#             if (index(gEpGuides[idx],".search.") && (i=index($0,"DirName"))>0) {
#ALL# 
#ALL#                 i += 8;
#ALL#                 $0 = substr($0,i);
#ALL#                 j=index($0,"\"");
#ALL#                 dirName=substr($0,1,j-1);
#ALL# 
#ALL#                 gEpGuides[idx]="http://epguides.com/"dirName;
#ALL# 
#ALL#             }
#ALL#             if ( gPoster[idx] == "" && gSettings["catalog_tv_poster_source"] == "epguides" ) {
#ALL#                 if (match($0,"<img[^<]+([Cc]ast|[Ss]how)[^<]+>")) {
#ALL#                     getPoster(gEpGuides[idx]"/"extractAttribute(substr($0,RSTART,RLENGTH),"img","src"),idx);
#ALL#                 }
#ALL#             }
#ALL#             if (index($0,"botnavbar")) {
#ALL#                 break;
#ALL#             }
#ALL#         }
#ALL#         close(f);
#ALL#     }
#ALL#     if (imdbLink == "" ) {
#ALL#         WARNING("getEpguideInfo returns blank imdb url");
#ALL#     } else {
#ALL#         DEBUG("getEpguideInfo returns imdb url ["imdbLink"]");
#ALL#     }
#ALL#     return imdbLink;
#ALL# }
#ALL# 
#ALL# # returns 1 if title adjusted or is the same.
#ALL# # returns 0 if title ignored.
#ALL# function adjustTitle(idx,newTitle,source) {
#ALL# 
#ALL#     if (!("filename" in gTitlePriority)) {
#ALL#         #initialise
#ALL#         gTitlePriority[""]=-1;
#ALL#         gTitlePriority["filename"]=0;
#ALL#         gTitlePriority["search"]=1;
#ALL#         gTitlePriority["imdb"]=2;
#ALL#         gTitlePriority["epguides"]=2;
#ALL#         gTitlePriority["thetvdb"]=3;
#ALL#         gTitlePriority["imdb_aka"]=3;
#ALL#     }
#ALL# 
#ALL#     if (!(source in gTitlePriority)) {
#ALL#         ERROR("Bad value ["source"] passed to adjustTitle");
#ALL#         return;
#ALL#     }
#ALL# 
#ALL#     if (gTitlePriority[source] > gTitlePriority[gTitleSource[idx]]) {
#ALL#         if (newTitle != gTitle[idx] ) {
#ALL#             DEBUG("title changed from "gTitleSource[idx]":["gTitle[idx]"] to "source":["newTitle"]");
#ALL#         } else {
#ALL#             DEBUG("title "gTitleSource[idx]":["gTitle[idx]"] matches "source":["newTitle"]");
#ALL#         }
#ALL#         gTitle[idx] = newTitle;
#ALL#         gTitleSource[idx] = source;
#ALL#         return 1;
#ALL#     } else {
#ALL#         DEBUG("title kept as "gTitleSource[idx]":["gTitle[idx]"] instead of "source":["newTitle"]");
#ALL#         return 0;
#ALL#     }
#ALL# }
#ALL# 
#ALL# function extractImdbId(text,\
#ALL# id) {
#ALL#     if (match(text,gImdbIdRegex)) {
#ALL#         id = substr(text,RSTART,RLENGTH);
#ALL#         DEBUG("Extracted IMDB Id ["id"]");
#ALL#     } else if (match(text,"Title.[0-9]+\\>")) {
#ALL#         id = "tt" substr(text,RSTART+8,RLENGTH-8);
#ALL#         DEBUG("Extracted IMDB Id ["id"]");
#ALL#     }
#ALL#     return id;
#ALL# }
#ALL# 
#ALL# # Try to read the title embedded in the iso.
#ALL# # This is stored after the first 32K of undefined data.
#ALL# # Normally strings would work but this is not on all platforms!
#ALL# # returns number of strings found and array of strings in outputText
#ALL# 
#ALL# function getIsoTitle(isoPath,\
#ALL# sep,tmpFile,f) {
#ALL#     FS="\\n";
#ALL#     sep="~";
#ALL#     outputWords=0;
#ALL#     tmpFile="/tmp/bytes."PID;
#ALL#     isoPart="/tmp/bytes."PID".2";
#ALL#     delete outputText;
#ALL# 
#ALL#     if (exec("dd if="quoteFile(isoPath)" of="isoPart" bs=1024 count=10 skip=32") != 0) {
#ALL#         return 0;
#ALL#     }
#ALL# 
#ALL#     DEBUG("Get strings "isoPath);
#ALL# 
#ALL#     DEBUG("tmp file "tmpFile);
#ALL# 
#ALL#     system("awk '\''BEGIN { FS=\"_\" } { gsub(/[^ -~]+/,\"~\"); gsub(\"~+\",\"~\") ; split($0,w,\"~\"); for (i in w)  if (w[i]) print w[i] ; }'\'' "isoPart" > "tmpFile);
#ALL#     getline f < tmpFile;
#ALL#     getline f < tmpFile;
#ALL#     system("rm -f -- "tmpFile" "isoPart);
#ALL#     INFO("iso title for "isoPath" = ["f"]");
#ALL#     gsub(/[Ww]in32/,"",f);
#ALL#     return cleanTitle(f);
#ALL# }
#ALL# 
#ALL# function extractImdbLink(text,\
#ALL# t) {
#ALL#     t = extractImdbId(text);
#ALL#     if (t != "") {
#ALL#         t = "http://www.imdb.com/title/"t;
#ALL#     }
#ALL#     return t;
#ALL# }
#ALL# 
#ALL# # Extracts Episode title and air date from imdb. 
#ALL# # In some cases epguides may incorrectly pass the imdb link for the pilot rather than the series.
#ALL# # In these cases it will switch to the series link and return that.
#ALL# # @idx = scan item
#ALL# # @imdbLink = base imdb link from which to derive episode link
#ALL# # @attempts = number of times a different base imdb link is tried. Only one attempt supported to 
#ALL# #   jump from pilot episode link to series link.
#ALL# function extractImdbEpisode(idx,imdbLink,attempts,\
#ALL# f,s,e,txt,imdbEpisodeUrl,referencedLink,referencedId) {
#ALL# 
#ALL#     INFO("extractImdbEpisode ["imdbLink"]");
#ALL#     imdbEpisodeUrl = imdbLink "/episodes";
#ALL# 
#ALL#     if (gEpTitleImdb[idx] != "" ) {
#ALL#         INFO("Episode details already set to "gEpTitleImdb[idx]);
#ALL#     } else {
#ALL#         f=getUrl(imdbEpisodeUrl,"imdb_episode",1);
#ALL#         if (f != "") {
#ALL#             FS="\n";
#ALL#             s=gSeason[idx];
#ALL#             e=gEpisode[idx];
#ALL# 
#ALL#             while((getline txt < f) > 0 ) {
#ALL# 
#ALL#                 #DEBUG("imdb episode:"txt);
#ALL# 
#ALL#                 if (index(txt,"Season "s", Episode "e":")) {
#ALL#                     gEpTitleImdb[idx]=extractTagText(txt,"a");
#ALL#                     gAirDateImdb[idx]=formatDate(extractTagText(txt,"strong"));
#ALL#                     DEBUG("imdb episode title = ["gEpTitleImdb[idx]"]");
#ALL#                     DEBUG("imdb air date = ["gAirDateImdb[idx]"]");
#ALL#                     break;
#ALL#                 }
#ALL# 
#ALL#                 # Check all episode links refer back to the same URL. If not then
#ALL#                 #We may have been passed a URL to an episode rather than to the series.
#ALL#                 #In this case we start again with the series link.
#ALL#                 if (match(txt,gImdbIdRegex "/episodes")) {
#ALL#                     referencedLink=substr(txt,RSTART,RLENGTH-9);
#ALL#                     INFO("ID = "extractImdbId(referencedLink));
#ALL#                     referencedId = substr(extractImdbId(referencedLink),3)+0;  #Get Id as a number.
#ALL# 
#ALL#                     if (match(imdbEpisodeUrl,"\\<tt0*"referencedId"\\>")) {
#ALL#                         #All OK - reference matches main URL
#ALL#                         referencedId = referencedLink = "";
#ALL#                     } else {
#ALL#                         INFO("Found another referenced episode link ["referencedLink"/"referencedId"]");
#ALL#                         break;
#ALL#                     }
#ALL#                 }
#ALL#             }
#ALL#             close(f);
#ALL#             if (referencedLink != "" && gEpTitleImdb[idx]=="" && gAirDateImdb[idx] == "") {
#ALL#                 INFO("Had IMDB link ["imdbEpisodeUrl"] but this may be an episode and ["referencedLink"] may be the series");
#ALL#                 if (attempts == 0) {
#ALL#                     return extractImdbEpisode(idx,extractImdbLink(referencedLink),attempts+1);
#ALL#                 }
#ALL#             }
#ALL# 
#ALL#         }
#ALL#     }
#ALL#     return imdbLink;
#ALL# }
#ALL# 
#ALL# function extractAttribute(str,tag,attr,\
#ALL#     tagPos,closeTag,endAttr,attrPos) {
#ALL# 
#ALL#     tagPos=index(str,"<"tag);
#ALL#     closeTag=indexFrom(str,">",tagPos);
#ALL#     attrPos=indexFrom(str,attr"=",tagPos);
#ALL#     if (attrPos == 0 || attrPos >= closeTag ) {
#ALL#         ERROR("ATTR "tag"/"attr" not in "str);
#ALL#         ERROR("tagPos is "tagPos" at "substr(str,tagPos));
#ALL#         ERROR("closeTag is "closeTag" at "substr(str,closeTag));
#ALL#         ERROR("attrPos is "attrPos" at "substr(str,attrPos));
#ALL#         return "";
#ALL#     }
#ALL#     attrPos += length(attr)+1;
#ALL#     if (substr(str,attrPos,1) == "\"" ) {
#ALL#         attrPos++;
#ALL#         endAttr=indexFrom(str,"\"",attrPos);
#ALL#     }  else  {
#ALL#         endAttr=indexFrom(str," ",attrPos);
#ALL#     }
#ALL#     #DEBUG("Extracted attribute value ["substr(str,attrPos,endAttr-attrPos)"] from tag ["substr(str,tagPos,closeTag-tagPos+1)"]");
#ALL#     return substr(str,attrPos,endAttr-attrPos);
#ALL# }
#ALL# 
#ALL# function extractTagText(str,startText,\
#ALL#     i,j) {
#ALL#     i=index(str,"<"startText);
#ALL#     i=indexFrom(str,">",i) + 1;
#ALL#     j=indexFrom(str,"<",i);
#ALL#     return trim(substr(str,i,j-i));
#ALL# }
#ALL# 
#ALL# function indexFrom(str,x,startPos,\
#ALL#     j) {
#ALL#     if (startPos<1) startPos=1;
#ALL#     j=index(substr(str,startPos),x);
#ALL#     if (j == 0) return 0;
#ALL#     return j+startPos-1;
#ALL# }
#ALL# 
#ALL# function url_encode(text) {
#ALL# 
#ALL#     if (index(text,"%")) { gsub(/[%]/,"%25",text); }
#ALL#     if (index(text,"?")) { gsub(/[?]/,"%3F",text); }
#ALL#     if (index(text,"&")) { gsub(/[&]/,"%26",text); }
#ALL#     if (index(text," ")) { gsub(/ /,"%20",text); }
#ALL#     if (index(text,":")) { gsub(/:/,"%3A",text); }
#ALL#     if (index(text,"=")) { gsub(/=/,"%3D",text); }
#ALL#     if (index(text,"(")) { gsub(/\(/,"%40",text); }
#ALL#     if (index(text,")")) { gsub(/\)/,"%41",text); }
#ALL#     if (index(text,"[")) { gsub(/\[/,"%5B",text); }
#ALL#     if (index(text,"]")) { gsub(/\]/,"%5D",text); }
#ALL#     if (index(text,"+")) { gsub(/[+]/,"%43",text); }
#ALL# 
#ALL#     return text;
#ALL# }
#ALL# 
#ALL# function decode_init(atoi,\
#ALL# i,c,h) {
#ALL#     DEBUG("create decode matrix");
#ALL#     for(i=0 ; i < 256 ; i++ ) {
#ALL#         c=sprintf("%c",i);
#ALL#         h=sprintf("x%02x",i);
#ALL#         atoi[i] = c;
#ALL#         atoi[h] = c;
#ALL#     }
#ALL# }
#ALL# function html_decode(text,\
#ALL# i,j,code,newcode) {
#ALL#     if (atoi[32] == "" ) {
#ALL#         decode_init(atoi);
#ALL#     }
#ALL#     i=0;
#ALL#     while((i=indexFrom(text,"&#",i)) > 0) {
#ALL#         DEBUG("i="i);
#ALL#         j=indexFrom(text,";",i);
#ALL#         code=tolower(substr(text,i+2,j-(i+2)));
#ALL# 
#ALL#         if (substr(code,1,1) == "x") {
#ALL#             newcode=atoi[code];
#ALL#         } else {
#ALL#             newcode=atoi[0+code];
#ALL#         }
#ALL#         text=substr(text,1,i-1) newcode substr(text,j+1);
#ALL#     }
#ALL#     #DEBUG("decode out =["text"]");
#ALL#     return text;
#ALL# }
#ALL# 
#ALL# function getUrl(url,capture_label,cache,\
#ALL#     f,label) {
#ALL#     
#ALL#     label="getUrl:"capture_label": ";
#ALL# 
#ALL#     DEBUG(label url);
#ALL# 
#ALL#     if (url == "" ) {
#ALL#         WARNING(label"Ignoring empty URL");
#ALL#         return;
#ALL#     }
#ALL# 
#ALL#     if(cache && (url in gUrlCache)) {
#ALL# 
#ALL#         INFO(label" fetched ["url"] from cache");
#ALL#         f = gUrlCache[url];
#ALL# 
#ALL#     } else {
#ALL# 
#ALL#         f=NEW_CAPTURE_FILE(capture_label);
#ALL#         if (wget(url,f) ==0) {
#ALL#             if (cache) {
#ALL#                 gUrlCache[url]=f;
#ALL#                 DEBUG(label" Cached url ["url"] to ["f"]");
#ALL#             } else {
#ALL#                 DEBUG(label" Fetched ["url"] into ["f"]"); 
#ALL#             }
#ALL#         } else {
#ALL#             ERROR(label" wget of ["url"] into ["f"] failed");
#ALL#             f = "";
#ALL#         }
#ALL#     }
#ALL#     return f;
#ALL# }
#ALL# 
#ALL# function wget(url,file,\
#ALL# args,ua,unzip_cmd,preCmd,postCmd,cmd,htmlFile,downloadedFile) {
#ALL#     ua="Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7) Gecko/20040613 Firefox/0.8.0+";
#ALL#     #ua="nmt-catalog";
#ALL# 
#ALL#     args=" -q -U \""ua"\" --waitretry=5 -t 4 ";
#ALL# 
#ALL#     targetFile=quoteFile(file);
#ALL#     htmlFile=targetFile;
#ALL# 
#ALL#     if(gunzip == "") {
#ALL#         downloadedFile=htmlFile;
#ALL#         unzip_cmd="";
#ALL#     } else {
#ALL#         args=" --header=\"Accept-Encoding: gzip,deflate\" "
#ALL#         downloadedFile=quoteFile(file".gz");
#ALL#         if (index(gunzip,"/home/alord/devel/oversight/gunzip.php")) {
#ALL#             unzip_cmd="&& \""gunzip"\" "downloadedFile" "htmlFile;
#ALL#         } else { 
#ALL#             unzip_cmd=" && ( gunzip "downloadedFile" || mv "downloadedFile" "htmlFile" ) ";
#ALL#         }
#ALL#     }
#ALL# 
#ALL#     gsub(/ /,"+",url);
#ALL# 
#ALL#     # nmt wget has a bug that causes a segfault if the url basename already exists and has no extension.
#ALL#     # To fix either make sure action url basename doesnt already exist (not easy with html redirects)
#ALL#     # or delete the -O target file and use the -c option together.
#ALL#     rm(downloadedFile,1);
#ALL#     args = args "  -c ";
#ALL# 
#ALL#     #d=tmp_dir"/wget."PID;
#ALL#     cmd = WGET" \""url"\" -O "downloadedFile" "args" "unzip_cmd  ;
#ALL#     #cmd="( mkdir "d" ; cd "d" ; "cmd" ; rm -fr -- "d" ) ";
#ALL#     # Get url if we havent got it before or it has zero size. --no-clobber switch doesnt work on NMT
#ALL# 
#ALL#     cmd = getSleepCommand(url,4) cmd;
#ALL# 
#ALL#     return exec(cmd);
#ALL# }
#ALL# 
#ALL# # Slow down queries to avoid blacklist.
#ALL# function getSleepCommand(url,required_gap,\
#ALL# slash,domain,remaining_gap) {
#ALL#     slash=indexFrom(url,"/",10); #http://x.com/xxxx 
#ALL#     domain=substr(url,1,slash);
#ALL#     #DEBUG("Domain = "domain);
#ALL# 
#ALL#     g_search_count[domain]++;
#ALL#     if (index(domain,"epguide") || index(domain,"imdb")) {
#ALL#         return "";
#ALL#     }
#ALL#     remaining_gap=required_gap - (systime()-last_search_time[domain]);
#ALL#     if ( last_search_time[domain] > 0 && remaining_gap > 0 ) {
#ALL# 
#ALL#         last_search_time[domain] = systime()+remaining_gap;
#ALL#         return "sleep "remaining_gap" ; ";
#ALL#     } else {
#ALL#         last_search_time[domain] = systime();
#ALL#         return "";
#ALL#     }
#ALL# }
#ALL# 
#ALL# function getPoster(url,idx,\
#ALL#     localPosterPath,localPosterName) {
#ALL# 
#ALL#     if (gSettings["catalog_fetch_posters"] == no) {
#ALL#         return;
#ALL#     }
#ALL#     localPosterName = gTitle[idx];
#ALL#     gsub(/[^a-zA-Z0-9]/,"",localPosterName);
#ALL# 
#ALL#     localPosterName = poster_prefix localPosterName ".jpg";
#ALL#     #DEBUG("poster _prefix = "poster_prefix);
#ALL#     #DEBUG("localPosterName = "localPosterName);
#ALL#     #DEBUG("gFolder[idx] = "gFolder[idx]);
#ALL#     url = getNicePosters(idx,url);
#ALL#     DEBUG("new poster url = "url);
#ALL# 
#ALL#     localPosterPath = getPath(localPosterName,gFolder[idx]);
#ALL#     DEBUG("localPosterPath = ["localPosterPath"]");
#ALL# 
#ALL#     #Get the poster if we havent fetched it already.
#ALL#     if (UPDATE_POSTERS == 1 || gPosterList[localPosterPath] == "" ) {
#ALL# 
#ALL#         #create the folder.
#ALL#         system(sprintf(" mkdir -p \"%s\" 2>/dev/null && rmdir \"%s\" ",localPosterPath,localPosterPath));
#ALL# 
#ALL#         if (exec(sprintf(WGET" -q -O %s %s",quoteFile(localPosterPath),quoteFile(url))) == 0 ) {
#ALL# 
#ALL#             gPosterList[localPosterPath] = 1;
#ALL# 
#ALL#             setPermissions(quoteFile(localPosterPath));
#ALL#         }
#ALL#     }
#ALL# 
#ALL#     gPoster[idx]=localPosterName;
#ALL#     DEBUG("Got poster="gPoster[idx]);
#ALL# }
#ALL# 
#ALL# function getNicePosters(idx,url,\
#ALL# id) {
#ALL#     #Remove /combined/episodes from urls given by epguides.
#ALL#     id = extractImdbId(gExternalSourceUrl[idx]);
#ALL# 
#ALL#     DEBUG("Poster check id = "id);
#ALL#     if (id != "" && gCategory[idx] == "M"  && index(gPoster[idx],"moviedb") ==  0 ) {
#ALL#         return getNiceMoviePosters(idx,url,id);
#ALL#     } else {
#ALL#         return url;
#ALL#     }
#ALL# }
#ALL# 
#ALL# #ALL# #movie db - search direct for imdbid then extract picture
#ALL# #ALL# function getNiceMoviePosters(idx,url,id,\
#ALL# #ALL# f,line,url2) {
#ALL# #ALL#     DEBUG("Poster check id = "url2);
#ALL# #ALL# 
#ALL# #ALL#     url2="http://www.themoviedb.org/search?search[text]="id;
#ALL# #ALL# 
#ALL# #ALL#     #Look for 
#ALL# #ALL#     #  /image/posters/12457/Fast_and_Furious_thumb.jpg
#ALL# #ALL#     #and replace with
#ALL# #ALL#     #  http://images.themoviedb.org/posters/12457/Fast_and_Furious_cover.jpg
#ALL# #ALL#     #  http://images.themoviedb.org/posters/12457/Fast_and_Furious.jpg
#ALL# #ALL#     url2=scanPageForMatch(url2,"[a-zA-Z0-9/:]+_thumb.jpg");
#ALL# #ALL# 
#ALL# #ALL#     if (url2 != "" ) {
#ALL# #ALL#         DEBUG("url = "url2);
#ALL# #ALL#         if (sub(/_thumb/,"_cover",url2) == 1) {
#ALL# #ALL#             DEBUG("url = "url2);
#ALL# #ALL#             if (sub(/.*\/image\//,"http://images.themoviedb.org/",url2) == 1) {
#ALL# #ALL#                 DEBUG("url = "url2);
#ALL# #ALL#             }
#ALL# #ALL#         }
#ALL# #ALL#     }
#ALL# #ALL#     return url2;
#ALL# #ALL# }
#ALL# 
#ALL# # Scan a page for matches to regular expression
#ALL# # matches = array of matches index 1,2,...
#ALL# # max = max number to match
#ALL# # returns match or empty.
#ALL# #ALL# function scanPageForMatch(url,regex,\
#ALL# #ALL# matches) {
#ALL# #ALL#     scanPageForMatches(url,regex,matches,1);
#ALL# #ALL#     return matches[1];
#ALL# #ALL# }
#ALL# 
#ALL# # Scan a page for matches to regular expression
#ALL# # matches = array of matches index 1,2,...
#ALL# # max = max number to match
#ALL# # return number of matches
#ALL# #ALL# function scanPageForMatches(url,regex,matches,max,\
#ALL# #ALL# f,line,count) {
#ALL# #ALL#     f=getUrl(url,"scan",1);
#ALL# #ALL# 
#ALL# #ALL#     count=0;
#ALL# #ALL#     if (f != "" ) {
#ALL# #ALL# 
#ALL# #ALL#         FS="\n";
#ALL# #ALL#         while((getline line < f) > 0  ) {
#ALL# #ALL#             if (match(line,regex)) {
#ALL# #ALL#                 matches[++count] = substr(line,RSTART,RLENGTH);
#ALL# #ALL#                 if (max > 0 && count-max >= 0) {
#ALL# #ALL#                     break;
#ALL# #ALL#                 }
#ALL# #ALL#             }
#ALL# #ALL#         }
#ALL# #ALL#         close(f);
#ALL# #ALL#     }
#ALL# #ALL#     return count;
#ALL# #ALL# }
#ALL# 
#ALL# 
#ALL# function scrapeIMDBLine(imdbContentPosition,idx,f,\
#ALL# l,i,p,r,title) {
#ALL# 
#ALL#     if (imdbContentPosition == "footer" ) {
#ALL#         return imdbContentPosition;
#ALL#     } else if (imdbContentPosition == "header" ) {
#ALL# 
#ALL#         #Only look for title at this stage
#ALL#         #First get the HTML Title
#ALL#         if (index($0,"<title>")) {
#ALL#             title = extractTagText($0,"title");
#ALL#             DEBUG("Title found ["title "] current title ["gTitle[idx]"]");
#ALL# 
#ALL#             title=checkIMDBTvTitle(idx,title);
#ALL#         }
#ALL#         if (index($0,"pagecontent")) {
#ALL#             imdbContentPosition="body";
#ALL#         }
#ALL# 
#ALL#     } else if (imdbContentPosition == "body") {
#ALL# 
#ALL#         if (index($0,">Company:")) {
#ALL#             DEBUG("Found company details - ending");
#ALL#             imdbContentPosition="footer";
#ALL#         } else {
#ALL# 
#ALL#             #This is the main information section
#ALL# 
#ALL#             if (gYear[idx] == "" && (y=index($0,"/Sections/Years/")) > 0) {
#ALL#                 gYear[idx] = substr($0,y+16,4);
#ALL#                 DEBUG("IMDB: Got year ["gYear[idx]"]");
#ALL#             }
#ALL#             if (gPoster[idx] == "" && index($0,"a name=\"poster\"")) {
#ALL#                 if (gCategory[idx] == "M" || gSettings["catalog_tv_poster_source"] == "imdb" ) {
#ALL#                     if (match($0,"src=\"[^\"]+\"")) {
#ALL# 
#ALL#                         poster_imdb_url = substr($0,RSTART+5,RLENGTH-5-1);
#ALL# 
#ALL#                         #Get high quality one
#ALL#                         sub(/SX[0-9]{2,3}_/,"SX400_",poster_imdb_url);
#ALL#                         sub(/SY[0-9]{2,3}_/,"SY400_",poster_imdb_url);
#ALL# 
#ALL#                         getPoster(poster_imdb_url,idx);
#ALL#                     }
#ALL#                 }
#ALL#             }
#ALL#             if (gPlot[idx] == "" && index($0,"Plot:")) {
#ALL#                 gPlot[idx] = scrapeIMDBPlot($0,f);
#ALL#             }
#ALL#             if (gGenre[idx] == "" && index($0,"Genre:")) {
#ALL#                 gGenre[idx]=scrapeIMDBGenre($0,f);
#ALL#             }
#ALL#             if (gRating[idx] == "" && index($0,"/10</b>") ) {
#ALL#                 gRating[idx]=0+extractTagText($0,"b");
#ALL#                DEBUG("IMDB: Got Rating = ["gRating[idx]"]");
#ALL#             }
#ALL#             if (index($0,"certificates")) {
#ALL# 
#ALL#                 scrapeIMDBCertificate(idx,$0);
#ALL# 
#ALL#             }
#ALL#             # Title is the hardest due to original language titling policy.
#ALL#             # Good Bad Ugly, Crouching Tiger, Two Brothers, Leon lots of fun!! 
#ALL# 
#ALL#             if (gOriginalTitle[idx] == gTitle[idx] && index($0,"Also Known As:")) {
#ALL# 
#ALL#                 scrapeIMDBAka(idx,$0);
#ALL# 
#ALL#             }
#ALL#         }
#ALL#     } else {
#ALL#         DEBUG("Unknown imdbContentPosition ["imdbContentPosition"]");
#ALL#     }
#ALL#     return imdbContentPosition;
#ALL# }
#ALL# 
#ALL# function checkIMDBTvTitle(idx,title,\
#ALL# semicolon,quote,quotePos,title2) {
#ALL#     #If title starts and ends with some hex code ( &xx;Name&xx; (2005) ) extract it and set tv type.
#ALL#     gCategory[idx]="M";
#ALL#     if (substr(title,1,1) == "&" ) {
#ALL#         semicolon=index(title,";");
#ALL#         if (semicolon > 0 ) { 
#ALL#             quote=substr(title,1,semicolon);
#ALL#             DEBUG("Imdb tv quote = <"quote">");
#ALL#             title2=substr(title,semicolon+1);
#ALL#             DEBUG("Imdb tv title = <"title2">");
#ALL#             quotePos = index(title2,quote);
#ALL#             if (quotePos > 0 ) {
#ALL#                 #rest=substr(title2,quotePos+length(quote));
#ALL#                 #if (match(/^ \([0-9]{4}\)$/,rest)) {
#ALL#                     title=substr(title2,1,quotePos-1);
#ALL#                     gCategory[idx]="T";
#ALL#                 #}
#ALL#             }
#ALL#         }
#ALL#     }
#ALL# 
#ALL#     #Remove the year
#ALL#     gsub(/ \((19|20)[0-9][0-9](\/I|)\) *(\([A-Z]+\)|)$/,"",title);
#ALL# 
#ALL#     title=cleanTitle(title);
#ALL#     if (adjustTitle(idx,title,"imdb")) {
#ALL#         gOriginalTitle[idx] = gTitle[idx];
#ALL#     }
#ALL#     return title;
#ALL# }
#ALL# 
#ALL# # Looks for matching country in AKA section. The first match must simply contain (country)
#ALL# # If it contains any qualifications then we stop looking at any more matches and reject the 
#ALL# # entire section.
#ALL# # This is because IMDB lists AKA in order of importance. So this helps weed out false matches
#ALL# # against alternative titles that are further down the list.
#ALL# 
#ALL# function scrapeIMDBAka(idx,line,\
#ALL# l,akas,a,c,exclude,e) {
#ALL# 
#ALL#     if (gOriginalTitle[idx] != gTitle[idx] ) return ;
#ALL# 
#ALL#     l=substr(line,index(line,"</h")+5);
#ALL#     split(l,akas,"<br>");
#ALL#     for(a in akas) {
#ALL#         DEBUG("Checking aka ["akas[a]"]");
#ALL#         for(c in gTitleCountries ) {
#ALL#             if (index(akas[a],"("gTitleCountries[c]":")) {
#ALL#                 #We hit a matching AKA country but it has some kind of qualification
#ALL#                 #which suggest that weve already passed a better match - ignore rest of section.
#ALL#                 DEBUG("Ignoring aka section");
#ALL#                 return;
#ALL#                 eEeE=")"; #Balance brakets in editor!
#ALL#             }
#ALL#             if (index(akas[a],"("gTitleCountries[c]")")) {
#ALL#                 #We hit a matching AKA country ...
#ALL#                 split("poster|working|literal|IMAX|promotional|long title|script title|closing credits|informal alternative",exclude,"|");
#ALL#                 for(e in exclude) {
#ALL#                     if (index(akas[a],exclude[e])) {
#ALL#                         #the qualifications again suggest that weve already passed a better match
#ALL#                         # ignore rest of section.
#ALL#                         DEBUG("Ignoring aka section");
#ALL#                         return;
#ALL#                     }
#ALL#                 }
#ALL# 			    #Use first match from AKA section 
#ALL# 			    adjustTitle(idx,substr(akas[a],1,index(akas[a]," (")-1),"imdb_aka"); 
#ALL# 			    return;
#ALL#                     
#ALL#             }
#ALL#         }
#ALL#     }
#ALL# }
#ALL# 
#ALL# function scrapeIMDBCertificate(idx,line,\
#ALL# l,cert,c) {
#ALL#     if ( match(line,"List[?]certificates=[^&]+")) {
#ALL#         #<a href="/List?certificates=UK:15&&heading=14;UK:15">
#ALL#         #<a href="/List?certificates=USA:R&&heading=14;USA:R">
#ALL# 
#ALL#         l=substr(line,RSTART,RLENGTH);
#ALL#         l=substr(l,index(l,"=")+1); # eg UK:15
#ALL#         split(l,cert,":");
#ALL#         DEBUG("IMDB: found certificate ["cert[1]"]["cert[2]"]");
#ALL#         
#ALL#         #Now we only want to assign the certificate if it is in our desired list of countries.
#ALL#         for(c = 1 ; (c in gCertificateCountries ) ; c++ ) {
#ALL#             if (gCertCountry[idx] == gCertificateCountries[c]) {
#ALL#                 #Keep certificate as this country is early in the list.
#ALL#                 return;
#ALL#             }
#ALL#             if (cert[1] == gCertificateCountries[c]) {
#ALL#                 #Update certificate
#ALL#                 gCertCountry[idx] = cert[1];
#ALL#                 gCertRating[idx] = cert[2];
#ALL#                 DEBUG("IMDB: set certificate ["gCertCountry[idx]"]["gCertRating[idx]"]");
#ALL#                 return;
#ALL#             }
#ALL#         }
#ALL#     }
#ALL# }
#ALL# function scrapeIMDBPlot(line,f,\
#ALL# p,i) {
#ALL#     getline p <f;
#ALL# 
#ALL#     #Full plot . keep it for next time
#ALL#     if ((i=index(p," <a")) > 0) {
#ALL#         p=substr(p,1,i-1);
#ALL#     }
#ALL#     if ((i=index(p,"|")) > 0) {
#ALL#         p=substr(p,1,i-1);
#ALL#     }
#ALL#     DEBUG("IMDB: Got plot = ["p"]");
#ALL#     return p;
#ALL# }
#ALL# function scrapeIMDBGenre(line,f,\
#ALL# l) {
#ALL#     getline l <f;
#ALL#     gsub(/<[^<>]+>/,"",l);
#ALL#     sub(/ +more */,"",l);
#ALL#     DEBUG("IMDB: Got genre = ["l"]");
#ALL#     return l;
#ALL# }
#ALL# 
#ALL# function relocate_files(i,\
#ALL#     newName,oldName) {
#ALL# 
#ALL#    DEBUG("relocate_files");
#ALL# 
#ALL#     newName="";
#ALL#     oldName="";
#ALL#     fileType="";
#ALL#     if (RENAME_TV == 1 && gCategory[i] == "T") {
#ALL# 
#ALL#         oldName=gFolder[i]"/"gMovieFiles[i];
#ALL#         newName=gSettings["catalog_tv_file_fmt"];
#ALL#         newName = substitute("SEASON",gSeason[i],newName);
#ALL#         newName = substitute("EPISODE",gEpisode[i],newName);
#ALL#         newName = substitute("INFO",gAdditionalInfo[i],newName);
#ALL# 
#ALL#         epTitle=gEpTitle[i];
#ALL#         if (epTitle == "") {
#ALL#             epTitle = gEpTitleImdb[i];
#ALL#         }
#ALL#         gsub(/[^-A-Za-z0-9,. ]/,"",epTitle);
#ALL#         gsub(/[{]EPTITLE[}]/,epTitle,newName);
#ALL# 
#ALL#         newName = substitute("EPTITLE",epTitle,newName);
#ALL#         newName = substitute("0SEASON",sprintf("%02d",gSeason[i]),newName);
#ALL#         newName = substitute("0EPISODE",padEpisode(gEpisode[i]),newName);
#ALL# 
#ALL#         fileType="file";
#ALL# 
#ALL#     } else if (RENAME_FILM==1 && gCategory[i] == "M") {
#ALL# 
#ALL#         oldName=gFolder[i];
#ALL#         newName=gSettings["catalog_film_folder_fmt"];
#ALL#         fileType="folder";
#ALL# 
#ALL#     } else {
#ALL#         return;
#ALL#     }
#ALL#     if (newName != "" && newName != oldName) {
#ALL# 
#ALL#         if (fileType == "file") {
#ALL#             newName = substitute("NAME",gMovieFiles[i],newName);
#ALL#             if (match(gMovieFiles[i],"\.[^.]+$")) {
#ALL#                 #DEBUG("BASE EXT="gMovieFiles[i] " AT "RSTART);
#ALL#                 newName = substitute("BASE",substr(gMovieFiles[i],1,RSTART-1),newName);
#ALL#                 newName = substitute("EXT",substr(gMovieFiles[i],RSTART),newName);
#ALL#             } else {
#ALL#                 #DEBUG("BASE EXT="gMovieFiles[i] "]");
#ALL#                 newName = substitute("BASE",gMovieFiles[i],newName);
#ALL#                 newName = substitute("EXT","",newName);
#ALL#             }
#ALL#         }
#ALL#         newName = substitute("DIR",gFolder[i],newName);
#ALL#         newName = substitute("TITLE",gTitle[i],newName);
#ALL#         newName = substitute("YEAR",gYear[i],newName);
#ALL#         newName = substitute("CERT",gCertRating[i],newName);
#ALL#         newName = substitute("GENRE",gGenre[i],newName);
#ALL# 
#ALL#         #Remove characters windows doesnt like
#ALL#         gsub(/[\\:*\"<>|]/,"_",newName); #"
#ALL#         #Remove double slahses
#ALL#         gsub(/\/\/+/,"/",newName);
#ALL# 
#ALL#         if (newName != oldName) {
#ALL#            if (fileType == "folder") {
#ALL#                if (moveFolder(i,oldName,newName) != 0) {
#ALL#                    return;
#ALL#                }
#ALL#                gFile[i]="";
#ALL#                gFolder[i]=newName;
#ALL#            } else {
#ALL# 
#ALL#                # Move media file
#ALL#                if (moveFile(oldName,newName) != 0 ) {
#ALL#                    return;
#ALL#                }
#ALL#                gFolderMediaCount[gFolder[i]]--;
#ALL#                gFile[i]=newName;
#ALL#                
#ALL#                oldFolder=gFolder[i];
#ALL# 
#ALL#                newFolder=newName;
#ALL#                sub(/\/[^\/]+$/,"",newFolder);
#ALL# 
#ALL#                #Update new folder location
#ALL#                gFolder[i]=newFolder;
#ALL# 
#ALL#                gMovieFiles[i]=newName;
#ALL#                sub(/.*\//,"",gMovieFiles[i]);
#ALL# 
#ALL#                # Move nfo file
#ALL#                if(gNfoExists[gNfoDefault[i]]) {
#ALL# 
#ALL#                    sub(/\.[^.]+$/,"",newName);
#ALL#                    newName = newName ".nfo";
#ALL# 
#ALL#                    if (moveFile(gNfoDefault[i],newName) != 0) {
#ALL#                        return;
#ALL#                    }
#ALL#                    if (!g_opt_dry_run) {
#ALL#                        delete gNfoExists[gNfoDefault[i]] ;
#ALL# 
#ALL#                        gDate[newName]=gDate[gNfoDefault[i]];
#ALL#                        delete gDate[gNfoDefault[i]];
#ALL# 
#ALL#                        gNfoDefault[i] = newName;
#ALL#                        gNfoExists[gNfoDefault[i]] = 1;
#ALL#                    }
#ALL#                }
#ALL# 
#ALL#                if(gPoster[i] != "" && substr(gPoster[i],1,1)!= "/" && substr(gPoster[i],1,4) != "ovs:" ) {
#ALL#                    oldName=oldFolder"/"gPoster[i];
#ALL#                    newName=newFolder"/"gPoster[i];
#ALL#                    if (moveFile(oldName,newName) != 0 ) {
#ALL#                        return;
#ALL#                    }
#ALL#                }
#ALL# 
#ALL#                #Rename any other associated files (sub,idx etc) etc.
#ALL#                rename_related(i,oldName,newName);
#ALL# 
#ALL#                #Move everything else from old to new.
#ALL#                moveFolder(i,oldFolder,newFolder);
#ALL#            }
#ALL#         }
#ALL#     } else {
#ALL#         # Name unchanged
#ALL#         if (g_opt_dry_run) {
#ALL#             print "dryrun:\t"newName" unchanged.";
#ALL#             print "dryrun:";
#ALL#         } else {
#ALL#             INFO("rename:\t"newName" unchanged.");
#ALL#         }
#ALL#     }
#ALL# }
#ALL# 
#ALL# function rm(x,quiet,quick) {
#ALL#     removeContent("rm -f -- ",x,quiet,quick);
#ALL# }
#ALL# function rmdir(x,quiet,quick) {
#ALL#     removeContent("rmdir -- ",x,quiet,quick);
#ALL# }
#ALL# function removeContent(cmd,x,quiet,quick) {
#ALL# 
#ALL#     if (!changeable(x)) return 1;
#ALL# 
#ALL#     if (!quiet) {
#ALL#         INFO("Deleting "x);
#ALL#     }
#ALL#     cmd=cmd quoteFile(x)" 2>/dev/null ";
#ALL#     if (quick) {
#ALL#         return "(" cmd ") & ";
#ALL#     } else {
#ALL#         return "(" cmd " || true ) ";
#ALL#     } 
#ALL# }
#ALL# 
#ALL# function substitute(keyword,value,str,\
#ALL#     oldStr) {
#ALL# 
#ALL#     oldStr=str;
#ALL#     if (index(value,"&")) {
#ALL#         gsub(/[&]/,"\\\\&",value);
#ALL#     }
#ALL#     if (index(str,keyword)) {
#ALL#         while(match(str,"[{][^{}]*:"keyword":[^{}]*[}]")) {
#ALL#             hold=substr(str,RSTART,RLENGTH);
#ALL#             if (value=="") {
#ALL#                 hold="";
#ALL#             } else {
#ALL#                 sub(":"keyword":",value,hold);
#ALL#                 hold=substr(hold,2,length(hold)-2); #remove braces
#ALL#             }
#ALL#             str=substr(str,1,RSTART-1) hold substr(str,RSTART+RLENGTH);
#ALL#         }
#ALL#     }
#ALL# 
#ALL#     if ( oldStr != str ) {
#ALL#         DEBUG("Keyword ["keyword"]=["value"]");
#ALL#         DEBUG("Old path ["oldStr"]");
#ALL#         DEBUG("New path ["str"]");
#ALL#     }
#ALL# 
#ALL#     return str;
#ALL# }
#ALL# 
#ALL# function rename_related(idx,oldName,newName,\
#ALL#     f,extensions,ext,oldBase,newBase) {
#ALL#     split("srt idx sub",extensions," ");
#ALL# 
#ALL#     oldBase = oldName;
#ALL#     sub(/\....$/,".",oldBase);
#ALL# 
#ALL#     newBase = newName;
#ALL#     sub(/\....$/,".",newBase);
#ALL# 
#ALL#     for(ext in extensions) {
#ALL#         moveFile(oldBase extensions[ext],newBase extensions[ext]);
#ALL#     }
#ALL# 
#ALL# }
#ALL# 
#ALL# function preparePath(quotedFile,\
#ALL# ret) {
#ALL#     if ((ret=system("mkdir -p "quotedFile)) != 0) {
#ALL#         ERROR("Failed to prepare "quotedFile" :file exists?");
#ALL#         return ret;
#ALL#     }
#ALL#     if ((ret=system("rmdir "quotedFile)) != 0) {
#ALL#         ERROR("Failed to prepare "quotedFile" :rm error "ret);
#ALL#         return ret;
#ALL#     }
#ALL#     return 0;
#ALL# }
#ALL# 
#ALL# #This is used to double check we are only manipulating files that meet certain criteria.
#ALL# #More checks can be added over time. This is to prevent accidental moving of high level files etc.
#ALL# #esp if the process has to run as root.
#ALL# function changeable(f) {
#ALL#     #TODO Expand to include only paths listed in scan list.
#ALL# 
#ALL#     #Check folder depth to avoid nasty accidents.
#ALL#     if (substr(f,1,5) == "/tmp/") return 1;
#ALL# 
#ALL#     if (!match(f,"/[^/]+/[^/]+/")) {
#ALL#         WARNING("Changing ["f"] might be risky. please make manual changes");
#ALL#         return 0;
#ALL#     }
#ALL#     return 1;
#ALL# }
#ALL# 
#ALL# function moveFile(oldName,newName,\
#ALL#     cmd,new,old,ret) {
#ALL# 
#ALL#     if (!changeable(oldName) ) {
#ALL#         return 1;
#ALL#     }
#ALL#     new=quoteFile(newName);
#ALL#     old=quoteFile(oldName);
#ALL#     if (g_opt_dry_run) {
#ALL#         if (match(oldName,gExtRegExAll) && system("test -f "old) == 0) {
#ALL#             print "dryrun: from "old
#ALL#             print "dryrun: to\t"new
#ALL#             print "dryrun:";
#ALL#         }
#ALL#         return 0;
#ALL#     } else {
#ALL#     # INFO("move file:\t"old" --> "new);
#ALL#         if ((ret=preparePath(new)) == 0) {
#ALL#             ret = exec("mv "old" "new);
#ALL#         }
#ALL#        return ret;
#ALL#    }
#ALL# }
#ALL# 
#ALL# function isDvdDir(f) {
#ALL#     return substr(f,length(f)) == "/";
#ALL# }
#ALL# 
#ALL# #Moves folder contents.
#ALL# function moveFolder(i,oldName,newName,\
#ALL#     cmd,new,old,ret,isDvdDir) {
#ALL# 
#ALL#    if (!(folderIsRelevant(oldName))) {
#ALL#        WARNING("["oldName"] not renamed as it was not listed in the arguments");
#ALL#        return 1;
#ALL#    } else if ( gFolderCount[oldName] > 2*(isDvdDir(gMovieFiles[i])) ) {
#ALL#        WARNING("["oldName"] not renamed to ["newName"] due to "gFolderCount[oldName]" sub folders");
#ALL#        return 1;
#ALL#    } else if (gFolderMediaCount[oldName] > 1) {
#ALL#        WARNING("["oldName"] not renamed to ["newName"] due to "gFolderMediaCount[oldName]" media files");
#ALL#        return 1;
#ALL#    } else if (!changeable(oldName) ) {
#ALL#        return 1;
#ALL#    } else {
#ALL#        new=quoteFile(newName);
#ALL#        old=quoteFile(oldName);
#ALL#        if (g_opt_dry_run) { 
#ALL#            print "dryrun: from "old"/* to "new"/";
#ALL#            return 0;
#ALL#        } else {
#ALL#            INFO("move folder:"old"/* --> "new"/");
#ALL#            cmd="mkdir -p "new" ;  mv "old"/* "new" ; mv "old"/.[^.]* "new" 2>/dev/null ; rmdir "old;
#ALL#            ret = exec(cmd);
#ALL#            system("rmdir "old" 2>/dev/null");
#ALL#        }
#ALL#        return ret;
#ALL#    }
#ALL# }
#ALL# 
#ALL# #Write a .nfo file if one didnt exist. This will make it easier 
#ALL# #to rebuild the DB_ARR at a later date. Esp if the file names are no
#ALL# #longer appearing in searches.
#ALL# function generate_nfo_file(nfoFormat,dbrow,\
#ALL# movie,tvshow,episodeguideurl,s,nfo,dbOne,fieldName,fieldId,i,nfoAdded) {
#ALL# 
#ALL#     nfoAdded=0;
#ALL#     if (gSettings["catalog_nfo_write"] == "never" ) {
#ALL#         return;
#ALL#     }
#ALL#     parseDbRow(dbrow,dbOne,1);
#ALL# 
#ALL#     DEBUG("NFO = "dbOne[NFO,1]);
#ALL#     DEBUG("DIR = "dbOne[DIR,1]);
#ALL#     nfo=getPath(dbOne[NFO,1],dbOne[DIR,1]);
#ALL# 
#ALL#     DEBUG("nfo = "nfo);
#ALL# 
#ALL#     if (gNfoExists[nfo] && gSettings["catalog_nfo_write"] != "always" ) {
#ALL#         DEBUG("nfo already exists - skip writing");
#ALL#         return;
#ALL#     }
#ALL#     DEBUG("nfo exists = "gNfoExists[nfo]);
#ALL# 
#ALL#     DEBUG("nfo style = "nfoFormat);
#ALL#     
#ALL#     if (nfoFormat == "xmbc" ) {
#ALL#         movie=","TITLE","ORIG_TITLE","RATING","YEAR","PLOT","POSTER","CERT","WATCHED","IMDBID","FILE","GENRE",";
#ALL#         tvshow=","TITLE","URL","RATING","PLOT","GENRE",";
#ALL#         episodedetails=","EPTITLE","SEASON","EPISODE","AIRDATE",";
#ALL#     }
#ALL# 
#ALL# 
#ALL#     if (nfo != "" && !gNfoExists[nfo]) {
#ALL#         DEBUG("Creating ["nfoFormat"] "nfo);
#ALL# 
#ALL#         if (nfoFormat == "xmbc") {
#ALL#             if (dbOne[CATEGORY,1] =="M") {
#ALL# 
#ALL#                 if (dbOne[URL,1] != "") {
#ALL#                     dbOne[IMDBID,1] = extractImdbId(dbOne[URL,1]);
#ALL#                 }
#ALL# 
#ALL#                 startXmbcNfo(nfo);
#ALL#                 writeXmbcTag(dbOne,"movie",movie,nfo);
#ALL#                 nfoAdded=1;
#ALL# 
#ALL#             } else if (dbOne[CATEGORY,1] == "T") {
#ALL# 
#ALL#                 startXmbcNfo(nfo);
#ALL#                 writeXmbcTag(dbOne,"tvshow",tvshow,nfo);
#ALL#                 writeXmbcTag(dbOne,"episodedetails",episodedetails,nfo);
#ALL#                 nfoAdded=1;
#ALL#             }
#ALL#         } else {
#ALL#             #Flat
#ALL#             print "#Auto Generated NFO" > nfo;
#ALL#             for (i in dbOne) {
#ALL#                 if (dbOne[i] != "") {
#ALL#                     fieldId = substr(i,1,length(i)-2);
#ALL#                     fieldName=gDbFieldName[fieldId];
#ALL#                     if (fieldName != "") {
#ALL#                         print fieldName"\t: "dbOne[i] > nfo;
#ALL#                     }
#ALL#                 }
#ALL#             }
#ALL#             nfoAdded=1;
#ALL#         }
#ALL#     }
#ALL#     if(nfoAdded) {
#ALL#         close(nfo);
#ALL#         gNfoExists[nfo]=1;
#ALL#         setPermissions(quoteFile(nfo));
#ALL#     }
#ALL# }
#ALL# 
#ALL# function startXmbcNfo(nfo) {
#ALL#     print "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" > nfo;
#ALL#     print "<!-- #Auto Generated NFO by catalog.sh -->" > nfo;
#ALL# }
#ALL# #dbOne = single row of index.db
#ALL# function writeXmbcTag(dbOne,tag,children,nfo,\
#ALL# idxPair,fieldId,fieldName,text) {
#ALL#     print "<"tag">" > nfo;
#ALL# 
#ALL#     attr["movie","id"]="moviedb=\"imdb\"";
#ALL# 
#ALL#     for (idxPair in dbOne) {
#ALL# 
#ALL#         text=dbOne[idxPair];
#ALL# 
#ALL#         if (text != "") {
#ALL#             fieldId = substr(idxPair,1,length(idxPair)-2);
#ALL#             if (index(children,fieldId)) {
#ALL#                 childTag=gDbFieldId2Tag[fieldId];
#ALL#                 if (childTag != "") {
#ALL#                     if (childTag == "thumb") {
#ALL#                        if (gSettings["catalog_poster_location"] == "with_media" ) {
#ALL#                             #print "\t<"childTag">file://"dbOne[DIR,1]"/"text"</"childTag">" > nfo;
#ALL#                             print "\t<"childTag">file://./"text"</"childTag">" > nfo;
#ALL#                         } else {
#ALL#                             print "\t<!-- Poster location not exported catalog_poster_location="gSettings["catalog_poster_location"]" -->" > nfo;
#ALL#                             print "\t<"childTag">"text"</"childTag">" > nfo;
#ALL#                         }
#ALL#                     } else {
#ALL#                         if (childTag == "watched" ) text=((text==1)?"true":"false");
#ALL#                         print "\t<"childTag" "attr[tag,childTag]">"text"</"childTag">" > nfo;
#ALL#                     }
#ALL#                 }
#ALL#             }
#ALL#         }
#ALL#     }
#ALL#     print "</"tag">" > nfo;
#ALL# }
#ALL# 
#ALL# # Some times epguides and imdb disagree. We only give a title if both are the same.
#ALL# #
#ALL# function fixTitles(idx) {
#ALL# 
#ALL#     # If no title set - just use the filename
#ALL#     if (gTitle[idx] == "") {
#ALL#         gTitle[idx] = gMovieFiles[idx];
#ALL#         sub(/.*\//,"",gTitle[idx]); #remove path
#ALL#         gsub(/[^A-Za-z0-9]/," ",gTitle[idx]); #remove odd chars
#ALL#         DEBUG("Setting title to file["gTitle[idx]"]");
#ALL#     }
#ALL# 
#ALL#     # If catalog_folder_titles set use the folder name
#ALL#     if ( gSettings["catalog_folder_titles"] == 1 ) {
#ALL#         gTitle[idx] = gFolder[idx];
#ALL#         gsub(/.*\//,"",gTitle[idx]); #Remove path
#ALL#         DEBUG("Setting title to folder["gTitle[idx]"]");
#ALL#     }
#ALL#     gTitle[idx]=cleanTitle(gTitle[idx]);
#ALL# }
#ALL# 
#ALL# function get_best_episode_title(idx,\
#ALL#     j,tvcom,epguideTitles,imdbTitle,egTitle) {
#ALL# 
#ALL#     if (gCategory[idx] != "T") return;
#ALL# 
#ALL#     DEBUG("gTvCom["idx"]=["gTvCom[idx]"]");
#ALL#     DEBUG("gEpTitle["idx"]=["EpTitle[idx]"]");
#ALL# 
#ALL#     split(gTvCom[idx],tvcom,"\t");
#ALL#     split(gEpTitle[idx],epguideTitles,"\t");
#ALL# 
#ALL#     imdbTitle=tolower(gEpTitleImdb[idx]);
#ALL#     if (epguideTitles[2] != "") {
#ALL#         DEBUG("Getting best episode title for "gTitle[idx]" s"gSeason[idx]"e"gEpisode[idx]" imdb"imdbTitle);
#ALL#     }
#ALL#     for(j in epguideTitles) {
#ALL#         DEBUG("Checking episode titles "epguideTitles[j]);
#ALL#         if (epguideTitles[j] != "" ) {
#ALL#           egTitle=tolower(epguideTitles[j]);
#ALL#           if (index(egTitle,imdbTitle ) == 1 || index(imdbTitle,egTitle) ==1 || index(imdbTitle,"Episode #") == 1) {
#ALL#             DEBUG("Title for epguides "epguideTitles[j]);
#ALL#             #Use the EpGuides title as this has part numbers.
#ALL#             gEpTitle[idx] = epguideTitles[j];
#ALL#             gTvCom[idx] = tvcom[j];
#ALL#             break;
#ALL#           } else {
#ALL#             DEBUG("Ignoring Title for epguides "epguideTitles[j]);
#ALL#           }
#ALL#         }
#ALL#     }
#ALL# }
#ALL# 
#ALL# function createIndexRow(i,dbSize,dbArr,file_to_db,\
#ALL# row) {
#ALL#     # Estimated download date. cant use nfo time as these may get overwritten.
#ALL#     estimate=gDate[gFolder[i]"/unpak.log"];
#ALL#     if (estimate == "") {
#ALL#         estimate=gDate[gFolder[i]"/unpak.txt"];
#ALL#     }
#ALL#     if (estimate == "") {
#ALL#         estimate = gFileTime[i];
#ALL#     }
#ALL# 
#ALL#     if (gFile[i] == "" ) {
#ALL#         gFile[i]=getPath(gMovieFiles[i],gFolder[i]);
#ALL#     }
#ALL#     gsub(/\/\/+/,"/",gFile[i]);
#ALL# 
#ALL#     if ((gFile[i] in gFolderCount ) && gFolderCount[gFile[i]]) {
#ALL#         DEBUG("Adjusting file for video_ts");
#ALL#         gFile[i] = gFile[i] "/";
#ALL#     }
#ALL# 
#ALL#     row="\t"ID"\t"(gMaxDatabaseId++);
#ALL# 
#ALL#     if (gFile[i] in file_to_db) {
#ALL#         dbIdx = file_to_db[gFile[i]];
#ALL#         row=row"\t"WATCHED"\t"dbArr[WATCHED,dbIdx];
#ALL#         row=row"\t"ACTION"\t"dbArr[ACTION,dbIdx];
#ALL#     } else {
#ALL#         row=row"\t"WATCHED"\t0";
#ALL#         row=row"\t"ACTION"\t0";
#ALL#     }
#ALL# 
#ALL#     #Title and Season must be kept next to one another to aid grepping.
#ALL#     row=row"\t"TITLE"\t"gTitle[i];
#ALL#     if (gOriginalTitle[i] != "" && gOriginalTitle[i] != gTitle[i] ) {
#ALL#         row=row"\t"ORIG_TITLE"\t"gOriginalTitle[i];
#ALL#     }
#ALL#     row=row"\t"SEASON"\t"gSeason[i];
#ALL# 
#ALL#     row=row"\t"EPISODE"\t"gEpisode[i];
#ALL# 
#ALL#     row=row"\t"SEASON0"\t"sprintf("%02d",gSeason[i]);
#ALL#     row=row"\t"EPISODE0"\t"padEpisode(gEpisode[i]);
#ALL# 
#ALL#     row=row"\t"YEAR"\t"gYear[i];
#ALL#     row=row"\t"FILE"\t"gFile[i];
#ALL#     row=row"\t"ADDITIONAL_INFO"\t"gAdditionalInfo[i];
#ALL#     row=row"\t"PARTS"\t"gParts[i];
#ALL#     row=row"\t"URL"\t"gExternalSourceUrl[i];
#ALL#     row=row"\t"CERT"\t"gCertCountry[i]":"gCertRating[i];
#ALL#     row=row"\t"GENRE"\t"gGenre[i];
#ALL#     row=row"\t"RATING"\t"gRating[i];
#ALL#     row=row"\t"PLOT"\t"gPlot[i];
#ALL#     row=row"\t"CATEGORY"\t"gCategory[i];
#ALL#     row=row"\t"POSTER"\t"gPoster[i];
#ALL#     row=row"\t"FILETIME"\t"gFileTime[i];
#ALL#     if (gMovieFileCount > 4) {
#ALL#         #bulk add - use the estimate download date as the index date.
#ALL#         #this helps the index to appear to have some chronological order
#ALL#         #on first build
#ALL#         row=row"\t"INDEXTIME"\t"estimate;
#ALL#     } else {
#ALL#         row=row"\t"INDEXTIME"\t"NOW;
#ALL#     }
#ALL#     row=row"\t"DOWNLOADTIME"\t"estimate;
#ALL#     #row=row"\t"SEARCH"\t"gSearch[i];
#ALL#     row=row"\t"PROD"\t"gProdCode[i];
#ALL#     row=row"\t"AIRDATE"\t"gAirDate[i];
#ALL#     row=row"\t"EPTITLEIMDB"\t"gEpTitleImdb[i];
#ALL#     row=row"\t"AIRDATEIMDB"\t"gAirDateImdb[i];
#ALL# 
#ALL#     row=row"\t"TVCOM"\t"gTvCom[i];
#ALL#     row=row"\t"EPTITLE"\t"gEpTitle[i];
#ALL#     nfo="";
#ALL#     print "NFO:"gNfoDefault[i];
#ALL#     print "NFOExists:"gNfoExists[gNfoDefault[i]];
#ALL# 
#ALL#     if (gNfoExists[gNfoDefault[i]] || gSettings["catalog_nfo_write"] != "never" ) {
#ALL#         nfo=gNfoDefault[i];
#ALL#         gsub(/.*\//,"",nfo);
#ALL#     }
#ALL#     row=row"\t"NFO"\t"nfo;
#ALL#     return row;
#ALL# }
#ALL# 
#ALL# function add_new_scanned_files_to_database(outputFile,db_size,db_arr,file_to_db,\
#ALL# i,row,fields,f) {
#ALL# 
#ALL#     DEBUG("add_new_scanned_files_to_database");
#ALL#     gMaxDatabaseId++;
#ALL# 
#ALL#     for(i in gMovieFiles) {
#ALL# 
#ALL#         if (gMovieFiles[i] == "") continue;
#ALL# 
#ALL#         row=createIndexRow(i,db_size,db_arr,file_to_db);
#ALL# 
#ALL#         DEBUG("Adding to db:"gMovieFiles[i]);
#ALL#         print row"\t" > outputFile;
#ALL# 
#ALL#         generate_nfo_file(gSettings["catalog_nfo_format"],row);
#ALL# 
#ALL#         split(row,fields,"\t");
#ALL#         for(f=1; (f in fields) ; f++) {
#ALL#             if (f%2) {
#ALL#                 if(fields[f] != "" ) INFO(inf"=["fields[f]"]");
#ALL#             } else {
#ALL#                 inf=gDbFieldName[fields[f]]; 
#ALL#             }
#ALL#         }
#ALL# 
#ALL#     }
#ALL#     close(outputFile);
#ALL# }
#ALL# function touchAndMove(x,y) {
#ALL#     system("touch \""x"\" ; mv \""x"\" \""y"\"");
#ALL# }
#ALL# 
#ALL# #--------------------------------------------------------------------
#ALL# # Convinience function. Create a new file to capture some information.
#ALL# # At the end capture files are deleted.
#ALL# #--------------------------------------------------------------------
#ALL# function NEW_CAPTURE_FILE(label,\
#ALL#     CAPTURE_FILE,suffix) {
#ALL#     suffix= "." CAPTURE_COUNT "__" label;
#ALL#     CAPTURE_FILE = CAPTURE_PREFIX PID suffix;
#ALL#     CAPTURE_COUNT++;
#ALL#    #DEBUG("New capture file "label" ["CAPTURE_FILE "]");
#ALL#     return CAPTURE_FILE;
#ALL# }
#ALL# 
#ALL# function clean_capture_files(\
#ALL# cmd,file) {
#ALL#     INFO("Clean up");
#ALL#     exec("rm -f -- \""CAPTURE_PREFIX PID "\".* ");
#ALL# }
#ALL# function INFO(x) {
#ALL#     print "[INFO]   "(systime()-ELAPSED_TIME)" : " x;
#ALL# }
#ALL# function WARNING(x) {
#ALL#     print "[WARNING] "x;
#ALL# }
#ALL# function ERROR(x) {
#ALL#     print "[ERROR] "x;
#ALL# }
#ALL# function DETAIL(x) {
#ALL#     print "[DETAIL] "x;
#ALL# }
#ALL# 
#ALL# function trim(str) {
#ALL#     gsub(/^ +/,"",str);
#ALL#     gsub(/ +$/,"",str);
#ALL#     return str;
#ALL# }
#ALL# #---------------------------------------------------------------------
#ALL# # HEAPSORT from wikipedia --------------------------------------------
#ALL# #---------------------------------------------------------------------
#ALL# # Adapted to sorts the data via the index array.
#ALL# function heapsort (count, fieldName,fieldOrder,idx,arr,
#ALL#     end,tmp) {
#ALL#     heapify(count,fieldName,fieldOrder,idx,arr);
#ALL#     end=count-1;
#ALL#     while (end > 0) {
#ALL#         tmp=idx[0];idx[0]=idx[end];idx[end]=tmp;
#ALL#         end--;
#ALL#         siftdown(fieldName,fieldOrder,idx,arr,0,end);
#ALL#     }
#ALL# }
#ALL# function heapify (count, fieldName,fieldOrder,idx,arr,
#ALL#     start) {
#ALL#     start=int((count-2)/2)
#ALL#     while (start >= 0) {
#ALL#         siftdown(fieldName,fieldOrder,idx,arr,start,count-1);
#ALL#         start--;
#ALL#     }
#ALL# }
#ALL# function siftdown (fieldName,fieldOrder,idx,arr,start,end,\
#ALL#     root,child,tmp) {
#ALL#     root=start;
#ALL#     while(root*2+1 <= end) {
#ALL#         child=root*2+1
#ALL#         if (child+1 <=end && compare(fieldName,fieldOrder,idx,arr,child,child+1) <= 0) {
#ALL#             child++;
#ALL#         }
#ALL#         if (compare(fieldName,fieldOrder,idx,arr,root,child) > 0) {
#ALL#             return
#ALL#         }
#ALL#         tmp=idx[root];idx[root]=idx[child];idx[child]=tmp;
#ALL#         root=child;
#ALL#     }
#ALL# }
#ALL# #Return true if idx1 < idx2 (if idx1 >= idx2 return 0)
#ALL# function compare(fieldName,fieldOrder,idx,arr,idx1,idx2,
#ALL#     a,b) {
#ALL# 
#ALL#    a=arr[fieldName,idx[idx1]];
#ALL#    b=arr[fieldName,idx[idx2]];
#ALL#    if  (a > b) {
#ALL#        return fieldOrder;
#ALL#    } else {
#ALL#        return -fieldOrder;
#ALL#    }
#ALL# }
#ALL# 
#ALL# #Move folder names from argument list
#ALL# function get_folders_from_args(folder_arr,\
#ALL# i,folderCount,moveDown) {
#ALL#     folderCount=0;
#ALL#     moveDown=0;
#ALL#     for(i = 1 ; i < ARGC ; i++ ) {
#ALL#             INFO("Arg:["ARGV[i]"]");
#ALL#         if (ARGV[i] == "IGNORE_NFO" ) {
#ALL#             g_opt_catalog_nfo_read="no";
#ALL#             moveDown++;
#ALL#         } else if (ARGV[i] == "REBUILD" ) {
#ALL#             REBUILD=1;
#ALL#             moveDown++;
#ALL#         } else if (ARGV[i] == "DEBUG" ) {
#ALL#             DBG=1;
#ALL#             moveDown++;
#ALL#         } else if (ARGV[i] == "NOACTIONS" ) {
#ALL#             g_opt_no_actions=1;
#ALL#             moveDown++;
#ALL#         } else if (ARGV[i] == "STDOUT" ) {
#ALL#             STDOUT=1;
#ALL#             moveDown++;
#ALL#         } else if (ARGV[i] == "DRYRUN" ) {
#ALL#             RENAME_TV=1;
#ALL#             RENAME_FILM=1;
#ALL#             g_opt_dry_run=1;
#ALL#             moveDown++;
#ALL#         } else if (ARGV[i] == "RENAME" ) {
#ALL#             RENAME_TV=1;
#ALL#             RENAME_FILM=1;
#ALL#             moveDown++;
#ALL#         } else if (ARGV[i] == "RENAME_TV" ) {
#ALL#             RENAME_TV=1;
#ALL#             moveDown++;
#ALL#         } else if (ARGV[i] == "RENAME_FILM" ) {
#ALL#             RENAME_FILM=1;
#ALL#             moveDown++;
#ALL#         } else if (ARGV[i] == "UPDATE_POSTERS" )  {
#ALL#             UPDATE_POSTERS=1;
#ALL#             moveDown++;
#ALL#         } else if (ARGV[i] == "RESCAN" )  {
#ALL#             RESCAN=1;
#ALL#             moveDown++;
#ALL#         } else if (match(ARGV[i],"^[a-zA-Z_]+=")) {
#ALL#             #variable assignment - keep for awk to process
#ALL#         } else {
#ALL#             # A folder or file
#ALL#             INFO("Scan Path:["ARGV[i]"]");
#ALL#             folder_arr[++folderCount] = ARGV[i];
#ALL#             moveDown++;
#ALL#         }
#ALL#     }
#ALL#     ARGC -= moveDown;
#ALL#     # Add dev null as dummy input
#ALL#     ARGV[ARGC++] = "/dev/null";
#ALL#     return folderCount;
#ALL# }
#ALL# 
#ALL# 
#ALL# function load_catalog_settings(file_name) {
#ALL# 
#ALL#     loadSettings(file_name);
#ALL# 
#ALL#     gSettings["catalog_ignore_paths"]=glob2re(gSettings["catalog_ignore_paths"]);
#ALL# 
#ALL#     #Replace dir1|dir2|dir3 with dir1.*|dir2.*|dir3.*
#ALL#     gsub(/[|]/,".*|",gSettings["catalog_ignore_paths"]);
#ALL#     gSettings["catalog_ignore_paths"]=gSettings["catalog_ignore_paths"]".*";
#ALL# 
#ALL#     gSettings["catalog_ignore_names"]=glob2re(gSettings["catalog_ignore_names"]);
#ALL# 
#ALL#     #catalog_scene_tags = csv2re(tolower(catalog_scene_tags));
#ALL# 
#ALL#     #Search engines used for simple keywords+"imdb" searches.
#ALL#     #google,msn and yahoo all about the same.
#ALL#     split(tolower(gSettings["catalog_search_engines"]),link_search_engines,"|");
#ALL# 
#ALL#     #Search engines used for for deep searches (when mapping obsucre filename to a title).
#ALL#     #Google seems much better at this compared to others.
#ALL#     #Could use Google for everything but it may think your network is infected
#ALL#     #when doing big scans.
#ALL#     split(tolower(gSettings["catalog_deep_search_engines"]),title_search_engines,"|");
#ALL#     web_search_count=0;
#ALL# 
#ALL#     #Override with command line setting
#ALL#     if (g_opt_catalog_nfo_read != "" ) {
#ALL#         gSettings["catalog_nfo_read"] = g_opt_catalog_nfo_read;
#ALL#     }
#ALL# }
#ALL# 
' PID=5988 NOW=20090627135942 WGET=/bin/wget LS=/share/bin/ls APPDIR=/home/alord/devel/oversight gunzip=/bin/gunzip INDEX_DB=/home/alord/devel/oversight/index.db DEBUG .
+ x=0
+ set -e
+ clean_tmp
+ rm -f '/tmp/catalog.[0-9]*__*' '/tmp/awk.[0-9]*.0_DUMMY'
+ chown alord:None /home/alord/devel/oversight/index.db /home/alord/devel/oversight/index.db.idx /home/alord/devel/oversight/index.db.idx.new /home/alord/devel/oversight/index.db.new /home/alord/devel/oversight/index.db.old
+ return 0
