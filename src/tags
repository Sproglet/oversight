!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
ARRAY_EXPAND	.\array.c	58;"	d	file:
BUFSIZE	.\array.c	211;"	d	file:
BUFSIZE	.\util.c	119;"	d	file:
BUFSIZE	.\util.c	185;"	d	file:
CFG_BUFSIZ	.\config.c	86;"	d	file:
DEFINE_HASHTABLE_INSERT	.\hashtable.h	101;"	d
DEFINE_HASHTABLE_ITERATOR_SEARCH	.\hashtable_itr.h	71;"	d
DEFINE_HASHTABLE_REMOVE	.\hashtable.h	137;"	d
DEFINE_HASHTABLE_SEARCH	.\hashtable.h	119;"	d
DbField	.\field.c	/^} DbField;$/;"	t	typeref:struct:__anon1	file:
ITEM_COUNT	.\tester.c	/^static const int ITEM_COUNT = 4000;$/;"	v	file:
POST_BUF	.\gaya_cgi.c	49;"	d	file:
__ARRAY_H_ALORD__	.\array.h	2;"	d
__CONFIG_H_ALORD__	.\config.h	2;"	d
__GAYA_CGI_H__	.\gaya_cgi.h	2;"	d
__HASHTABLE_CWC22_H__	.\hashtable.h	4;"	d
__HASHTABLE_ITR_CWC22__	.\hashtable_itr.h	4;"	d
__HASHTABLE_PRIVATE_CWC22_H__	.\hashtable_private.h	4;"	d
__UTIL_H_ALORD__	.\util.h	2;"	d
__XHASHTABLE_CWC22_UTILITY_H__	.\hashtable_utility.h	4;"	d
appDir	.\util.c	/^char *appDir() {$/;"	f
array	.\array.h	/^    void **array;$/;"	m	struct:array_str
array	.\array.h	/^typedef struct array_str array;$/;"	t	typeref:struct:array_str
array_add	.\array.c	/^void array_add(array *a,void *ptr) {$/;"	f
array_free	.\array.c	/^void array_free(array *a) {$/;"	f
array_new	.\array.c	/^array *array_new(void(*free_fn)(void *)) {$/;"	f
array_print	.\array.c	/^void array_print(char *label,array *a) {$/;"	f
array_set	.\array.c	/^void array_set(array *a,int idx,void *ptr) {$/;"	f
array_str	.\array.h	/^struct array_str {$/;"	s
array_unittest	.\array.c	/^void array_unittest() {$/;"	f
catalog_config	.\oversight.c	/^struct hashtable *catalog_config = NULL;$/;"	v	typeref:struct:hashtable
chomp	.\util.c	/^void chomp(char *str) {$/;"	f
config_load	.\config.c	/^struct hashtable *config_load(char *filename) {$/;"	f
config_load_fp	.\config.c	/^struct hashtable *config_load_fp(FILE *fp) {$/;"	f
config_load_wth_defaults	.\config.c	/^struct hashtable *config_load_wth_defaults(char *d,char *defaults_file,char *main_file) {$/;"	f
config_unittest	.\config.c	/^void config_unittest() {$/;"	f
config_write	.\config.c	/^void config_write(struct hashtable *cfg,char *filename) {$/;"	f
config_write_fp	.\config.c	/^void config_write_fp(struct hashtable *cfg,FILE *fp) {$/;"	f
create_hashtable	.\hashtable.c	/^create_hashtable(unsigned int minsize,$/;"	f
e	.\hashtable_itr.h	/^    struct entry *e;$/;"	m	struct:hashtable_itr	typeref:struct:hashtable_itr::entry
entry	.\hashtable_private.h	/^struct entry$/;"	s
entrycount	.\hashtable_private.h	/^    unsigned int entrycount;$/;"	m	struct:hashtable
eqfn	.\hashtable_private.h	/^    int (*eqfn) (void *k1, void *k2);$/;"	m	struct:hashtable
equalkeys	.\tester.c	/^equalkeys(void *k1, void *k2)$/;"	f	file:
exists	.\util.c	/^int exists(char *path) {$/;"	f
freeDbField	.\field.c	/^void freeDbField(DbField **f) {$/;"	f
free_fn	.\array.h	/^    void (*free_fn)(void *);$/;"	m	struct:array_str
freekey	.\hashtable_private.h	46;"	d
from_hex	.\gaya_cgi.c	/^char from_hex(char ch) {$/;"	f
from_hex	.\urlcode.c	/^char from_hex(char ch) {$/;"	f
h	.\hashtable_itr.h	/^    struct hashtable *h;$/;"	m	struct:hashtable_itr	typeref:struct:hashtable_itr::hashtable
h	.\hashtable_private.h	/^    unsigned int h;$/;"	m	struct:entry
hash	.\hashtable.c	/^hash(struct hashtable *h, void *k)$/;"	f
hashfn	.\hashtable_private.h	/^    unsigned int (*hashfn) (void *k);$/;"	m	struct:hashtable
hashfromkey	.\tester.c	/^hashfromkey(void *ky)$/;"	f	file:
hashtable	.\hashtable_private.h	/^struct hashtable {$/;"	s
hashtable_change	.\hashtable_utility.c	/^hashtable_change(struct hashtable *h, void *k, void *v)$/;"	f
hashtable_count	.\hashtable.c	/^hashtable_count(struct hashtable *h)$/;"	f
hashtable_destroy	.\hashtable.c	/^hashtable_destroy(struct hashtable *h, int free_values)$/;"	f
hashtable_dump	.\util.c	/^void hashtable_dump(char *label,struct hashtable *h) {$/;"	f
hashtable_expand	.\hashtable.c	/^hashtable_expand(struct hashtable *h)$/;"	f	file:
hashtable_insert	.\hashtable.c	/^hashtable_insert(struct hashtable *h, void *k, void *v)$/;"	f
hashtable_iterator	.\hashtable_itr.c	/^hashtable_iterator(struct hashtable *h)$/;"	f
hashtable_iterator_advance	.\hashtable_itr.c	/^hashtable_iterator_advance(struct hashtable_itr *itr)$/;"	f
hashtable_iterator_key	.\hashtable_itr.c	/^hashtable_iterator_key(struct hashtable_itr *i)$/;"	f
hashtable_iterator_key	.\hashtable_itr.h	/^hashtable_iterator_key(struct hashtable_itr *i)$/;"	f
hashtable_iterator_remove	.\hashtable_itr.c	/^hashtable_iterator_remove(struct hashtable_itr *itr)$/;"	f
hashtable_iterator_search	.\hashtable_itr.c	/^hashtable_iterator_search(struct hashtable_itr *itr,$/;"	f
hashtable_iterator_value	.\hashtable_itr.c	/^hashtable_iterator_value(struct hashtable_itr *i)$/;"	f
hashtable_iterator_value	.\hashtable_itr.h	/^hashtable_iterator_value(struct hashtable_itr *i)$/;"	f
hashtable_itr	.\hashtable_itr.h	/^struct hashtable_itr$/;"	s
hashtable_remove	.\hashtable.c	/^hashtable_remove(struct hashtable *h, void *k)$/;"	f
hashtable_search	.\hashtable.c	/^hashtable_search(struct hashtable *h, void *k)$/;"	f
id	.\field.c	/^	char *id;$/;"	m	struct:__anon1	file:
id	.\tester.c	/^    char *id;$/;"	m	struct:value	file:
index	.\hashtable_itr.h	/^    unsigned int index;$/;"	m	struct:hashtable_itr
indexFor	.\hashtable_private.h	/^indexFor(unsigned int tablelength, unsigned int hashvalue) {$/;"	f
is_dir	.\util.c	/^int is_dir(char *path) {$/;"	f
is_executable	.\util.c	/^int is_executable(char *path) {$/;"	f
is_file	.\util.c	/^int is_file(char *path) {$/;"	f
is_local_browser	.\gaya_cgi.c	/^int is_local_browser() {$/;"	f
is_pc_browser	.\gaya_cgi.c	/^int is_pc_browser() {$/;"	f
is_readable	.\util.c	/^int is_readable(char *path) {$/;"	f
is_writeable	.\util.c	/^int is_writeable(char *path) {$/;"	f
join_str_fmt_free	.\util.c	/^char *join_str_fmt_free(char *fmt,char *s1,char *s2) {$/;"	f
k	.\hashtable_private.h	/^    void *k, *v;$/;"	m	struct:entry
key	.\tester.c	/^struct key$/;"	s	file:
loadlimit	.\hashtable_private.h	/^    unsigned int loadlimit;$/;"	m	struct:hashtable
main	.\oversight.c	/^int main(int argc,char **argv) {$/;"	f
main	.\tester.c	/^main(int argc, char **argv)$/;"	f
max_load_factor	.\hashtable.c	/^const float max_load_factor = 0.65;$/;"	v
mem_size	.\array.h	/^    int mem_size;$/;"	m	struct:array_str
merge_hashtables	.\util.c	/^void merge_hashtables(struct hashtable *h1,struct hashtable *h2,int copy) {$/;"	f
newDbField	.\field.c	/^DbField *newDbField(char *id,char *v) {$/;"	f
next	.\hashtable_private.h	/^    struct entry *next;$/;"	m	struct:entry	typeref:struct:entry::entry
nmt_chown	.\util.c	/^void nmt_chown(char *d) {$/;"	f
nmt_gid	.\util.c	/^int nmt_gid() {$/;"	f
nmt_mkdir	.\util.c	/^int nmt_mkdir(char *d) {$/;"	f
nmt_passwd	.\util.c	/^static struct passwd *nmt_passwd = NULL;$/;"	v	typeref:struct:passwd	file:
nmt_subdir	.\util.c	/^char *nmt_subdir(char *root,char *name) {$/;"	f
nmt_uid	.\util.c	/^int nmt_uid() {$/;"	f
one_ip	.\tester.c	/^    uint32_t one_ip; uint32_t two_ip; uint16_t one_port; uint16_t two_port;$/;"	m	struct:key	file:
one_port	.\tester.c	/^    uint32_t one_ip; uint32_t two_ip; uint16_t one_port; uint16_t two_port;$/;"	m	struct:key	file:
oversight_config	.\oversight.c	/^struct hashtable *oversight_config = NULL;$/;"	v	typeref:struct:hashtable
parent	.\hashtable_itr.h	/^    struct entry *parent;$/;"	m	struct:hashtable_itr	typeref:struct:hashtable_itr::entry
parse_query_string	.\gaya_cgi.c	/^struct hashtable *parse_query_string(char *q,struct hashtable *hashtable_in) {$/;"	f
prime_table_length	.\hashtable.c	/^const unsigned int prime_table_length = sizeof(primes)\/sizeof(primes[0]);$/;"	v
primeindex	.\hashtable_private.h	/^    unsigned int primeindex;$/;"	m	struct:hashtable
primes	.\hashtable.c	/^static const unsigned int primes[] = {$/;"	v	file:
read_post_data	.\gaya_cgi.c	/^struct hashtable *read_post_data(char *post_filename) {$/;"	f
regextract	.\util.c	/^array *regextract(char *s,char *pattern) {$/;"	f
regextract1	.\util.c	/^char *regextract1(char *s,char *pattern,int submatch) {$/;"	f
regextract_free	.\util.c	/^void regextract_free(array *submatches) {$/;"	f
regpos	.\util.c	/^int regpos(char *s,char *pattern) {$/;"	f
replace_all	.\util.c	/^char *replace_all(char *s_in,char *pattern,char *replace) {$/;"	f
size	.\array.h	/^    int size;$/;"	m	struct:array_str
split	.\array.c	/^array *split(char *s_in,char *pattern) {$/;"	f
splitch	.\array.c	/^array *splitch(char *s_in,char ch) {$/;"	f
string_string_hashtable	.\util.c	/^struct hashtable *string_string_hashtable() {$/;"	f
stringcmp	.\util.c	/^int stringcmp(void *a,void *b) {$/;"	f
stringhash	.\util.c	/^unsigned int stringhash(void *vptr) {$/;"	f
substring	.\util.c	/^char *substring(char *s,int start_pos, int end_pos) {$/;"	f
table	.\hashtable_private.h	/^    struct entry **table;$/;"	m	struct:hashtable	typeref:struct:hashtable::entry
tablelength	.\hashtable_private.h	/^    unsigned int tablelength;$/;"	m	struct:hashtable
tmpDir	.\util.c	/^char *tmpDir() {$/;"	f
to_hex	.\gaya_cgi.c	/^char to_hex(char code) {$/;"	f
to_hex	.\urlcode.c	/^char to_hex(char code) {$/;"	f
two_ip	.\tester.c	/^    uint32_t one_ip; uint32_t two_ip; uint16_t one_port; uint16_t two_port;$/;"	m	struct:key	file:
two_port	.\tester.c	/^    uint32_t one_ip; uint32_t two_ip; uint16_t one_port; uint16_t two_port;$/;"	m	struct:key	file:
uint16_t	.\tester.c	/^typedef unsigned short uint16_t;$/;"	t	file:
uint32_t	.\tester.c	/^typedef unsigned int uint32_t;$/;"	t	file:
url	.\oversight2.html	/^function url(args) {$/;"	f
url_decode	.\gaya_cgi.c	/^char *url_decode(char *str) {$/;"	f
url_decode	.\urlcode.c	/^char *url_decode(char *str) {$/;"	f
url_encode	.\gaya_cgi.c	/^char *url_encode(char *str) {$/;"	f
url_encode	.\urlcode.c	/^char *url_encode(char *str) {$/;"	f
util_unittest	.\util.c	/^void util_unittest() {$/;"	f
v	.\hashtable_private.h	/^    void *k, *v;$/;"	m	struct:entry
value	.\field.c	/^	char *value;$/;"	m	struct:__anon1	file:
value	.\tester.c	/^struct value$/;"	s	file:
