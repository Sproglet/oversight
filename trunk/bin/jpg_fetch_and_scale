#!/bin/sh

# $Id:$
#
# Call libjpeb commands to resize a backdrop

OVS_HOME=/share/Apps/oversight

export PATH="$OVS_HOME/bin:$PATH"

ARCH=
if [ -f /mnt/syb8634/MIN_FIRMWARE_VER ] ;then
    ARCH=nmt100
    export PATH="$OVS_HOME/bin/$ARCH:$PATH"
    export LD_LIBRARY_PATH="$OVS_HOME/bin/$ARCH:$LD_LIBRARY_PATH"
else
    if [ -f /nmt/apps/MIN_FIRMWARE_VER ] ; then
        ARCH=nmt200
        export PATH="$OVS_HOME/bin/$ARCH:$PATH"
        export LD_LIBRARY_PATH="$OVS_HOME/bin/$ARCH:$LD_LIBRARY_PATH"
    fi
fi

TMP=/share/Apps/oversight/tmp
if [ ! -d $TMP ] ; then 
    TMP=/tmp
fi


jpg_resize() {

    # resize a jpeg to Sd or Hd backdrop

    input="$1"
    type="$2"
    tv_mode="$3"

    o=
    case "$type" in 
        fanart)
            case "$tv_mode" in 
                hd)   o="-width=1280 -height=720" ;;
                sd) o="-width=685 -height=460" ;;
                pal)  o="-width=685 -height=522" ;; # There is a a/r bug in gaya for pal display
            esac
            suffix=".$tv_mode.jpg"
            ;;
        poster)
            o="-width=300"
            suffix=".jpg"
            ;;
    esac

    if [  X == "X$o" ] ; then
        cat <<HERE
  unknown type $type
  usage: $0 file.jpg poster hd 
         $0 file.jpg fanart hd|sd|pal [width]
HERE
        exit 1
    fi

    
    output=`echo "$input" | sed "s/\.jpg$/$suffix/"`


    #Could use a pipe but input may = output so use tmp file.
    # We always resize even if the dimensions are unchanged because it makes file size much smaller
    INFO "$input | $o | $output" 
    # Remove it first in case it was a hard link to the original file.
    if djpeg -dct fast "$input" | pnmscalefixed $o | cjpeg -dct fast -quality 65 >  $TMP/$$.jpg && rm -f "$output" && mv $TMP/$$.jpg "$output"  ; then
        perms "$output"
    else
        ERROR "Unable to generate $output from $input using $o"
    fi
}

if [ "$1" != "start" -a -z "$3" ] ; then
	echo "usage $0 [poster|fanart] url file wget options"
	echo "usage $0 start"
	exit 1
fi

perms() {
    chown nmt:nmt "$@"
}

fetch_resize() {
    calling_pid="$1"; shift;
    type="$1" ; shift; # poster or fanart
    url="$1" ; shift;
    file="$1" ; shift ;

    INFO "Processing : $type $url $file"

    if wget -O "$file" "$@" "$url"  ; then
        perms $file
        if [ -s "$file" ] ; then
            #resize_wait
            resize_img "$type" "$file"  # &
        else
            rm -f "$file"
            ERROR "Failed wget -O $file $@ $url"
        fi
    else
        rm -f "$file"
    fi
}

resize_wait() {
   while running $Q.resizing ; do
       sleep 2
   done
   echo $$ > $Q.resizing
}

resize_img() {
    type="$1" ; shift; # poster or fanart
    file="$1" ; shift ;
    case "$type" in
        fanart)
            jpg_resize "$file" $type hd
            jpg_resize "$file" $type pal
            jpg_resize "$file" $type sd
            ;;
        poster)
            jpg_resize "$file" $type sd
            ;;
    esac
    rm -f "$Q.resizing"
}

Q=$TMP/resize.queue

add_queue() {
    args=
    for i in "$@" ; do
        i="`echo "$i" | sed "s/'/'\\''/g;s/^/'/;s/$/'/"`"
        args="$args $i"
    done
    echo "$args" >> $Q.pending
    chmod 666 "$Q.pending"
    INFO "Queued $args"
}


running() {
    if [ -f $1 ] ; then
        if [ -d /proc/`cat $1` ] ; then
            return 0
        else
            rm -f "$1"
        fi
    fi
    return 1
}

INFO() {
    echo "[INFO]`date +%H:%M:%S` jpeg queue : $@"
}

ERROR() {
    echo "[ERROR]`date +%H:%M:%S` jpeg queue : $@"
}


pid_file=$Q.pid
# Due to memory limits we process one request at a time.
if running $pid_file ; then
    add_queue  "$@"
else
    echo $$ > $pid_file

    if [ -n "$*" ] ; then
        add_queue  "$@"
    fi

    if [ `cat $pid_file` == $$ ] ; then 

        while [ -f "$Q.pending" ] ; do

            mv "$Q.pending" "$Q.tmp"
            cat "$Q.tmp" >> "$Q.processing"
            chmod 666 "$Q.processing"
            rm "$Q.tmp"

            while FS= read line ; do

                eval fetch_resize $line

            done < "$Q.processing"

            rm -f "$Q.processing"


        done

        rm -f $pid_file
        INFO "Shutting down"
    fi
fi

