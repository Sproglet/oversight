!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
ARRAY_EXPAND	.\array.c	59;"	d	file:
Array	.\array.h	/^typedef struct array_str Array;$/;"	t	typeref:struct:array_str
BUFSIZE	.\array.c	212;"	d	file:
BUFSIZE	.\db.c	61;"	d	file:
BUFSIZE	.\util.c	154;"	d	file:
BUFSIZE	.\util.c	88;"	d	file:
CFG_BUFSIZ	.\config.c	89;"	d	file:
DB_MEDIA_TYPE_ANY	.\db.h	15;"	d
DB_MEDIA_TYPE_FILM	.\db.h	14;"	d
DB_MEDIA_TYPE_TV	.\db.h	13;"	d
DB_WATCHED_FILTER_ANY	.\db.h	19;"	d
DB_WATCHED_FILTER_NO	.\db.h	18;"	d
DB_WATCHED_FILTER_YES	.\db.h	17;"	d
DEFINE_HASHTABLE_INSERT	.\hashtable.h	101;"	d
DEFINE_HASHTABLE_ITERATOR_SEARCH	.\hashtable_itr.h	71;"	d
DEFINE_HASHTABLE_REMOVE	.\hashtable.h	137;"	d
DEFINE_HASHTABLE_SEARCH	.\hashtable.h	119;"	d
Db	.\db.h	/^} Db;$/;"	t	typeref:struct:Db_struct
DbField	.\field.c	/^} DbField;$/;"	t	typeref:struct:__anon1	file:
DbResults_struct	.\db.h	/^typedef struct DbResults_struct {$/;"	s
DbRowId	.\db.h	/^} DbRowId;$/;"	t	typeref:struct:Dbrowid_struct
Db_struct	.\db.h	/^typedef struct Db_struct {$/;"	s
Dbrowid_struct	.\db.h	/^typedef struct Dbrowid_struct {$/;"	s
Dimensions	.\config.h	/^} Dimensions ;$/;"	t	typeref:struct:dimension_str
ITEM_COUNT	.\tester.c	/^static const int ITEM_COUNT = 4000;$/;"	v	file:
MALLOC	.\util.c	/^void *MALLOC(unsigned long bytes) {$/;"	f
POST_BUF	.\gaya_cgi.c	54;"	d	file:
STRDUP	.\util.c	/^char *STRDUP(char *s) {$/;"	f
__ARRAY_H_ALORD__	.\array.h	2;"	d
__CONFIG_H_ALORD__	.\config.h	2;"	d
__DB_ALORD__	.\db.h	2;"	d
__GAYA_CGI_H__	.\gaya_cgi.h	2;"	d
__HASHTABLE_CWC22_H__	.\hashtable.h	4;"	d
__HASHTABLE_ITR_CWC22__	.\hashtable_itr.h	4;"	d
__HASHTABLE_LOOP_ALORD__	.\hashtable_loop.h	5;"	d
__HASHTABLE_PRIVATE_CWC22_H__	.\hashtable_private.h	4;"	d
__OVS_VASPRINTF__GNU__	.\vasprintf.h	2;"	d
__UTIL_H_ALORD__	.\util.h	2;"	d
__XHASHTABLE_CWC22_UTILITY_H__	.\hashtable_utility.h	4;"	d
appDir	.\util.c	/^char *appDir() {$/;"	f
array	.\array.h	/^    void **array;$/;"	m	struct:array_str
array_add	.\array.c	/^void array_add(Array *a,void *ptr) {$/;"	f
array_free	.\array.c	/^void array_free(Array *a) {$/;"	f
array_new	.\array.c	/^Array *array_new(void(*free_fn)(void *)) {$/;"	f
array_print	.\array.c	/^void array_print(char *label,Array *a) {$/;"	f
array_set	.\array.c	/^void array_set(Array *a,int idx,void *ptr) {$/;"	f
array_str	.\array.h	/^struct array_str {$/;"	s
array_unittest	.\array.c	/^void array_unittest() {$/;"	f
button_size	.\config.h	/^    long button_size;$/;"	m	struct:dimension_str
catalog_config	.\oversight.c	/^struct hashtable *catalog_config = NULL;$/;"	v	typeref:struct:hashtable
certificate_size	.\config.h	/^    long certificate_size;$/;"	m	struct:dimension_str
chomp	.\util.c	/^void chomp(char *str) {$/;"	f
cols	.\config.h	/^    long cols;$/;"	m	struct:dimension_str
config_check_long	.\config.c	/^int config_check_long(struct hashtable *h,char *key,long *out) {$/;"	f
config_check_long_indexed	.\config.c	/^int config_check_long_indexed(struct hashtable *h,char *k,char *index,long *out) {$/;"	f
config_check_str	.\config.c	/^int config_check_str(struct hashtable *h,char *key,char **out) {$/;"	f
config_check_str_indexed	.\config.c	/^int config_check_str_indexed(struct hashtable *h,char *k,char *index,char **out) {$/;"	f
config_get_long	.\config.c	/^int config_get_long(struct hashtable *h,char *key,long *out) {$/;"	f
config_get_long_indexed	.\config.c	/^int config_get_long_indexed(struct hashtable *h,char *k,char *index,long *out) {$/;"	f
config_get_str	.\config.c	/^int config_get_str(struct hashtable *h,char *key,char **out) {$/;"	f
config_get_str_indexed	.\config.c	/^int config_get_str_indexed(struct hashtable *h,char *k,char *index,char **out) {$/;"	f
config_load	.\config.c	/^struct hashtable *config_load(char *filename) {$/;"	f
config_load_fp	.\config.c	/^struct hashtable *config_load_fp(FILE *fp) {$/;"	f
config_load_wth_defaults	.\config.c	/^struct hashtable *config_load_wth_defaults(char *d,char *defaults_file,char *main_file) {$/;"	f
config_read_dimensions	.\config.c	/^void config_read_dimensions(struct hashtable *ovs_cfg,struct hashtable *nmt_cfg,Dimensions *dim) {$/;"	f
config_unittest	.\config.c	/^void config_unittest() {$/;"	f
config_write	.\config.c	/^void config_write(struct hashtable *cfg,char *filename) {$/;"	f
config_write_fp	.\config.c	/^void config_write_fp(struct hashtable *cfg,FILE *fp) {$/;"	f
create_hashtable	.\hashtable.c	/^create_hashtable(unsigned int minsize,$/;"	f
db	.\db.h	/^    Db *db;$/;"	m	struct:DbResults_struct
db_create_hashtable	.\db.c	/^struct hashtable *db_create_hashtable() {$/;"	f
db_init	.\db.c	/^Db *db_init(char *filename, \/\/ path to the file$/;"	f
db_lock	.\db.c	/^int db_lock() {$/;"	f
db_row_equalf	.\db.c	/^unsigned int db_row_equalf(DbRow *r1,DbRow *r2) {$/;"	f
db_row_hashf	.\db.c	/^unsigned int db_row_hashf(DbRow *row) {$/;"	f
db_scan_titles	.\db.c	/^void db_scan_titles($/;"	f
db_unlock	.\db.c	/^int db_unlock() {$/;"	f
dimension_str	.\config.h	/^typedef struct dimension_str {$/;"	s
e	.\hashtable_itr.h	/^    struct entry *e;$/;"	m	struct:hashtable_itr	typeref:struct:hashtable_itr::entry
entry	.\hashtable_private.h	/^struct entry$/;"	s
entrycount	.\hashtable_private.h	/^    unsigned int entrycount;$/;"	m	struct:hashtable
eqfn	.\hashtable_private.h	/^    int (*eqfn) (void *k1, void *k2);$/;"	m	struct:hashtable
equalkeys	.\tester.c	/^equalkeys(void *k1, void *k2)$/;"	f	file:
exists	.\util.c	/^int exists(char *path) {$/;"	f
font_size	.\config.h	/^    long font_size;$/;"	m	struct:dimension_str
freeDbField	.\field.c	/^void freeDbField(DbField **f) {$/;"	f
free_fn	.\array.h	/^    void (*free_fn)(void *);$/;"	m	struct:array_str
freekey	.\hashtable_private.h	46;"	d
from_hex	.\gaya_cgi.c	/^char from_hex(char ch) {$/;"	f
from_hex	.\urlcode.c	/^char from_hex(char ch) {$/;"	f
get_scanlines	.\config.c	/^long get_scanlines(struct hashtable *nmt_settings,int *is_pal) {$/;"	f
h	.\hashtable_itr.h	/^    struct hashtable *h;$/;"	m	struct:hashtable_itr	typeref:struct:hashtable_itr::hashtable
h	.\hashtable_private.h	/^    unsigned int h;$/;"	m	struct:entry
hash	.\hashtable.c	/^hash(struct hashtable *h, void *k)$/;"	f
hashfn	.\hashtable_private.h	/^    unsigned int (*hashfn) (void *k);$/;"	m	struct:hashtable
hashfromkey	.\tester.c	/^hashfromkey(void *ky)$/;"	f	file:
hashtable	.\hashtable_private.h	/^struct hashtable {$/;"	s
hashtable_change	.\hashtable_utility.c	/^hashtable_change(struct hashtable *h, void *k, void *v)$/;"	f
hashtable_count	.\hashtable.c	/^hashtable_count(struct hashtable *h)$/;"	f
hashtable_destroy	.\hashtable.c	/^hashtable_destroy(struct hashtable *h, int free_values)$/;"	f
hashtable_dump	.\util.c	/^void hashtable_dump(char *label,struct hashtable *h) {$/;"	f
hashtable_expand	.\hashtable.c	/^hashtable_expand(struct hashtable *h)$/;"	f	file:
hashtable_insert	.\hashtable.c	/^hashtable_insert(struct hashtable *h, void *k, void *v)$/;"	f
hashtable_iterator	.\hashtable_itr.c	/^hashtable_iterator(struct hashtable *h)$/;"	f
hashtable_iterator_advance	.\hashtable_itr.c	/^hashtable_iterator_advance(struct hashtable_itr *itr)$/;"	f
hashtable_iterator_key	.\hashtable_itr.c	/^hashtable_iterator_key(struct hashtable_itr *i)$/;"	f
hashtable_iterator_key	.\hashtable_itr.h	/^hashtable_iterator_key(struct hashtable_itr *i)$/;"	f
hashtable_iterator_remove	.\hashtable_itr.c	/^hashtable_iterator_remove(struct hashtable_itr *itr)$/;"	f
hashtable_iterator_search	.\hashtable_itr.c	/^hashtable_iterator_search(struct hashtable_itr *itr,$/;"	f
hashtable_iterator_value	.\hashtable_itr.c	/^hashtable_iterator_value(struct hashtable_itr *i)$/;"	f
hashtable_iterator_value	.\hashtable_itr.h	/^hashtable_iterator_value(struct hashtable_itr *i)$/;"	f
hashtable_itr	.\hashtable_itr.h	/^struct hashtable_itr$/;"	s
hashtable_loop_init	.\hashtable_loop.c	/^struct hashtable_itr * hashtable_loop_init(struct hashtable *h) {$/;"	f
hashtable_loop_more	.\hashtable_loop.c	/^int hashtable_loop_more(struct hashtable_itr *itr,void *k,void *v) {$/;"	f
hashtable_remove	.\hashtable.c	/^hashtable_remove(struct hashtable *h, void *k)$/;"	f
hashtable_search	.\hashtable.c	/^hashtable_search(struct hashtable *h, void *k)$/;"	f
html_comment	.\gaya_cgi.c	/^void html_comment(char *format,...) {$/;"	f
html_encode	.\gaya_cgi.c	/^char *html_encode(char *s) {$/;"	f
html_error	.\gaya_cgi.c	/^void html_error(char *format,...) {$/;"	f
html_hashtable_dump	.\gaya_cgi.c	/^void html_hashtable_dump(int level,char *label,struct hashtable *h) {$/;"	f
html_hashtable_dump2	.\gaya_cgi.c	/^void html_hashtable_dump2(int level,char *label,struct hashtable *h) {$/;"	f
html_log	.\gaya_cgi.c	/^void html_log(int level,char *format,...) {$/;"	f
html_log_level	.\gaya_cgi.c	/^int html_log_level = 0;$/;"	v
html_log_level_set	.\gaya_cgi.c	/^void html_log_level_set(int level) {$/;"	f
html_vacomment	.\gaya_cgi.c	/^void html_vacomment(char *format,va_list ap) {$/;"	f
id	.\db.h	/^    long id;$/;"	m	struct:Dbrowid_struct
id	.\field.c	/^	char *id;$/;"	m	struct:__anon1	file:
id	.\tester.c	/^    char *id;$/;"	m	struct:value	file:
index	.\hashtable_itr.h	/^    unsigned int index;$/;"	m	struct:hashtable_itr
indexFor	.\hashtable_private.h	/^indexFor(unsigned int tablelength, unsigned int hashvalue) {$/;"	f
is_dir	.\util.c	/^int is_dir(char *path) {$/;"	f
is_executable	.\util.c	/^int is_executable(char *path) {$/;"	f
is_file	.\util.c	/^int is_file(char *path) {$/;"	f
is_local_browser	.\gaya_cgi.c	/^int is_local_browser() {$/;"	f
is_pc_browser	.\gaya_cgi.c	/^int is_pc_browser() {$/;"	f
is_readable	.\util.c	/^int is_readable(char *path) {$/;"	f
is_writeable	.\util.c	/^int is_writeable(char *path) {$/;"	f
join_str_fmt_free	.\util.c	/^char *join_str_fmt_free(char *fmt,char *s1,char *s2) {$/;"	f
k	.\hashtable_private.h	/^    void *k, *v;$/;"	m	struct:entry
key	.\tester.c	/^struct key$/;"	s	file:
loadlimit	.\hashtable_private.h	/^    unsigned int loadlimit;$/;"	m	struct:hashtable
main	.\oversight.c	/^int main(int argc,char **argv) {$/;"	f
main	.\tester.c	/^main(int argc, char **argv)$/;"	f
max_load_factor	.\hashtable.c	/^const float max_load_factor = 0.65;$/;"	v
max_plot_length	.\config.h	/^    long max_plot_length;$/;"	m	struct:dimension_str
mem_size	.\array.h	/^    int mem_size;$/;"	m	struct:array_str
merge_hashtables	.\util.c	/^void merge_hashtables(struct hashtable *h1,struct hashtable *h2,int copy) {$/;"	f
movie_img_width	.\config.h	/^    long movie_img_width;$/;"	m	struct:dimension_str
newDbField	.\field.c	/^DbField *newDbField(char *id,char *v) {$/;"	f
next	.\hashtable_private.h	/^    struct entry *next;$/;"	m	struct:entry	typeref:struct:entry::entry
nmt_chown	.\util.c	/^void nmt_chown(char *d) {$/;"	f
nmt_gid	.\util.c	/^int nmt_gid() {$/;"	f
nmt_mkdir	.\util.c	/^int nmt_mkdir(char *d) {$/;"	f
nmt_passwd	.\util.c	/^static struct passwd *nmt_passwd = NULL;$/;"	v	typeref:struct:passwd	file:
nmt_settings	.\oversight.c	/^struct hashtable *nmt_settings = NULL;$/;"	v	typeref:struct:hashtable
nmt_subdir	.\util.c	/^char *nmt_subdir(char *root,char *name) {$/;"	f
nmt_uid	.\util.c	/^int nmt_uid() {$/;"	f
offset	.\db.h	/^    long offset;$/;"	m	struct:Dbrowid_struct
one_ip	.\tester.c	/^    uint32_t one_ip; uint32_t two_ip; uint16_t one_port; uint16_t two_port;$/;"	m	struct:key	file:
one_port	.\tester.c	/^    uint32_t one_ip; uint32_t two_ip; uint16_t one_port; uint16_t two_port;$/;"	m	struct:key	file:
oversight_config	.\oversight.c	/^struct hashtable *oversight_config = NULL;$/;"	v	typeref:struct:hashtable
ovs_asprintf	.\vasprintf.c	/^int ovs_asprintf (char **result, char *format, ...)$/;"	f
ovs_vasprintf	.\vasprintf.c	/^int ovs_vasprintf (char **result, char *format, va_list args) {$/;"	f
parent	.\hashtable_itr.h	/^    struct entry *parent;$/;"	m	struct:hashtable_itr	typeref:struct:hashtable_itr::entry
parse_query_string	.\gaya_cgi.c	/^struct hashtable *parse_query_string(char *q,struct hashtable *hashtable_in) {$/;"	f
path	.\db.h	/^    char *path;$/;"	m	struct:Db_struct
poster_menu_img_height	.\config.h	/^    long poster_menu_img_height;$/;"	m	struct:dimension_str
poster_menu_img_width	.\config.h	/^    long poster_menu_img_width;$/;"	m	struct:dimension_str
poster_mode	.\config.h	/^    long poster_mode;$/;"	m	struct:dimension_str
prime_table_length	.\hashtable.c	/^const unsigned int prime_table_length = sizeof(primes)\/sizeof(primes[0]);$/;"	v
primeindex	.\hashtable_private.h	/^    unsigned int primeindex;$/;"	m	struct:hashtable
primes	.\hashtable.c	/^static const unsigned int primes[] = {$/;"	v	file:
read_post_data	.\gaya_cgi.c	/^struct hashtable *read_post_data(char *post_filename) {$/;"	f
regextract	.\util.c	/^Array *regextract(char *s,char *pattern) {$/;"	f
regextract1	.\util.c	/^char *regextract1(char *s,char *pattern,int submatch) {$/;"	f
regextract_free	.\util.c	/^void regextract_free(Array *submatches) {$/;"	f
regpos	.\util.c	/^int regpos(char *s,char *pattern) {$/;"	f
replace_all	.\util.c	/^char *replace_all(char *s_in,char *pattern,char *replace) {$/;"	f
rows	.\config.h	/^    long rows;$/;"	m	struct:dimension_str
rows	.\db.h	/^    struct hashtable *rows; \/\/ This is a hash of RowIds$/;"	m	struct:DbResults_struct	typeref:struct:DbResults_struct::hashtable
scanlines	.\config.h	/^    long scanlines;$/;"	m	struct:dimension_str
size	.\array.h	/^    int size;$/;"	m	struct:array_str
source	.\db.h	/^    char *source;$/;"	m	struct:Db_struct
split	.\array.c	/^Array *split(char *s_in,char *pattern) {$/;"	f
splitch	.\array.c	/^Array *splitch(char *s_in,char ch) {$/;"	f
string_string_hashtable	.\util.c	/^struct hashtable *string_string_hashtable() {$/;"	f
stringcmp	.\util.c	/^int stringcmp(void *a,void *b) {$/;"	f
stringhash	.\util.c	/^unsigned int stringhash(void *vptr) {$/;"	f
substring	.\util.c	/^char *substring(char *s,int start_pos, int end_pos) {$/;"	f
table	.\hashtable_private.h	/^    struct entry **table;$/;"	m	struct:hashtable	typeref:struct:hashtable::entry
tablelength	.\hashtable_private.h	/^    unsigned int tablelength;$/;"	m	struct:hashtable
title_size	.\config.h	/^    long title_size;$/;"	m	struct:dimension_str
tmpDir	.\util.c	/^char *tmpDir() {$/;"	f
to_hex	.\gaya_cgi.c	/^char to_hex(char code) {$/;"	f
to_hex	.\urlcode.c	/^char to_hex(char code) {$/;"	f
tv_img_width	.\config.h	/^    long tv_img_width;$/;"	m	struct:dimension_str
two_ip	.\tester.c	/^    uint32_t one_ip; uint32_t two_ip; uint16_t one_port; uint16_t two_port;$/;"	m	struct:key	file:
two_port	.\tester.c	/^    uint32_t one_ip; uint32_t two_ip; uint16_t one_port; uint16_t two_port;$/;"	m	struct:key	file:
uint16_t	.\tester.c	/^typedef unsigned short uint16_t;$/;"	t	file:
uint32_t	.\tester.c	/^typedef unsigned int uint32_t;$/;"	t	file:
url	.\oversight2.html	/^function url(args) {$/;"	f
url_decode	.\gaya_cgi.c	/^char *url_decode(char *str) {$/;"	f
url_decode	.\urlcode.c	/^char *url_decode(char *str) {$/;"	f
url_encode	.\gaya_cgi.c	/^char *url_encode(char *str) {$/;"	f
url_encode	.\urlcode.c	/^char *url_encode(char *str) {$/;"	f
util_unittest	.\util.c	/^void util_unittest() {$/;"	f
v	.\hashtable_private.h	/^    void *k, *v;$/;"	m	struct:entry
value	.\field.c	/^	char *value;$/;"	m	struct:__anon1	file:
value	.\tester.c	/^struct value$/;"	s	file:
